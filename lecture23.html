<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Focal X - Node.js Bootcamp: Lecture 23 </title>
    <link rel="manifest" href="./manifest.json" />
    <link rel="apple-touch-icon" href="./logo.jpg">
    <meta name="apple-mobile-web-app-status-bar" content="#aa7700">
    <meta name="theme-color" content="#b21f1f">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: #333;
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .footer {
            padding-top: 30px;
        }

        .footer a {
            color: black;
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }
        
        .container {
            width: 100%;
            max-width: 1200px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .coach {
            background-color: white;
            width: 80px;
            border-radius: 0 0 50% 0;
            color: black;
            padding: 10px;
            position: absolute;
            left: 0;
            top: 0;
        }
        
        header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
            height: 65vh;
        }
        
        .lecture-content {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }
        
        .interactive-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }
        
        h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
            font-size: 1.5rem;
        }
        
        h3 {
            color: #2980b9;
            margin: 20px 0 12px;
            font-size: 1.2rem;
        }
        
        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 12px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 12px 0;
            font-size: 0.9rem;
        }
        
        code {
            font-family: 'Fira Code', monospace;
        }
        
        .question {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }
        
        .options {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin: 12px 0;
        }
        
        .option {
            padding: 10px;
            background: #e8f4fc;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 0.9rem;
        }
        
        .option:hover {
            background: #d1e9fa;
        }
        
        .correct {
            background: #d4edda;
            border: 1px solid #c3e6cb;
        }
        
        .incorrect {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
        }
        
        .task {
            background: #fff3cd;
            padding: 12px;
            border-left: 5px solid #ffc107;
            margin: 15px 0;
            border-radius: 5px;
            font-size: 0.9rem;
        }
        
        .btn {
            display: inline-block;
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s;
            margin-top: 8px;
        }
        
        .btn:hover {
            background: #2980b9;
        }
        
        .result {
            margin-top: 12px;
            padding: 12px;
            border-radius: 5px;
            display: none;
            font-size: 0.9rem;
        }
        
        .search-task {
            background: #e7f5e9;
            padding: 12px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 5px solid #28a745;
            font-size: 0.9rem;
        }
        
        .tabs {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }
        
        .tab {
            padding: 8px 15px;
            cursor: pointer;
            background: #f1f1f1;
            border: 1px solid #ddd;
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }
        
        .tab.active {
            background: #6f42c1;
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 12px 0;
            font-size: 0.9rem;
        }
        
        .comparison-table th, .comparison-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        
        .comparison-table th {
            background-color: #3498db;
            color: white;
        }
        
        .comparison-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        @media (max-width: 900px) {
            .content {
                grid-template-columns: 1fr;
                height: auto;
            }
            
            .lecture-content, .interactive-section {
                height: 50vh;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <p class="coach">Moones Mezher</p>
        <header>
            <h1 id="lecture-title">Focal X - Node.js Bootcamp</h1>
            <p class="subtitle" id="lecture-subtitle">Node</p>
        </header>
        
        <div class="content">
            <div class="lecture-content">
                <h2>Lecture Content</h2>
                <div id="tabs-container"></div>
                <div id="tab-content-container"></div>
            </div>
            
            <div class="interactive-section">
                <h2>Interactive Questions & Tasks</h2>
                <div id="questions-container"></div>
            </div>
        </div>
    </div>

    <footer class="footer">
        <p>&copy; 2025 <a rel="noopener" href="https://focal-x.com/" target="_blank">Focal X</a> All Right Reserved</p>
    </footer>

        <script src="./reg.js"></script>
<script>
        // ==================== CONFIGURATION ====================
        // Update these arrays to change the content of your lecture
        
        // Lecture metadata
        const lectureConfig = {
            title: "Focal X - Node.js Bootcamp",
            subtitle: "MongoDB & ExpressJS (Advanced)"
        };
        
       // Lecture content organized by tabs
const lectureContent = [
    {
        tabTitle: "Last Lesson",
        title: "Last Lesson Recap",
        content: `/*
1- Populate
2- Pagination
3- Static 
4- Plugins
*/`
    },
    {
        tabTitle: "Auth Fundamentals",
        title: "Authentication & Authorization Fundamentals",
        content: `// ###################### AUTHENTICATION vs AUTHORIZATION ##############################

/*
1. Authentication (Who are you?)
   - Verifying user identity
   - Examples: Username/password, Social login, Biometrics
   - Answers: "Is this person who they claim to be?"

2. Authorization (What can you do?)
   - Checking permissions after authentication
   - Examples: Role-based access, Permission levels
   - Answers: "What is this person allowed to do?"

3. Real-world Analogy:
   - Hotel Key Card System:
     ‚Ä¢ Authentication: Checking your ID at front desk
     ‚Ä¢ Authorization: Your key card only opens your room, not others
*/

// ###################### MODERN AUTHENTICATION CONCEPTS ##############################

/*
Authentication Methods:
‚Ä¢ Password-based (traditional)
‚Ä¢ Multi-factor (MFA/2FA)
‚Ä¢ Social OAuth (Google, GitHub, Facebook)
‚Ä¢ Biometric (Face ID, Fingerprint)
‚Ä¢ Passwordless (Magic links, WebAuthn)
‚Ä¢ Single Sign-On (SSO)

Authorization Models:
‚Ä¢ Role-Based Access Control (RBAC)
‚Ä¢ Permission-based systems
‚Ä¢ Scope-based access (OAuth2)
‚Ä¢ Attribute-Based Access Control (ABAC)
*/

// ###################### AUTH FLOW OVERVIEW ##############################

/*
Modern Authentication Flow:

1. Registration/Login ‚Üí Credentials verification
2. Multi-factor authentication (if enabled)
3. Token generation (Access + Refresh tokens)
4. Secure token storage (HTTP-only cookies)
5. Automatic token inclusion in requests
6. Token validation + permission checks
7. Token refresh mechanism

    Client          Server          Database
    |                |                |
    |‚îÄ‚îÄ Login ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                |
    ‚îÇ                ‚îÇ‚Üê Verify Creds ‚Üí‚îÇ
    ‚îÇ                ‚îÇ‚Üê Check MFA ‚îÄ‚îÄ‚îÄ>‚îÇ
    ‚îÇ                ‚îÇ‚Üê Generate JWT ‚îÄ‚îÇ
    ‚îÇ‚Üê Set Cookies ‚îÄ‚îÄ‚îÇ                ‚îÇ
    ‚îÇ                ‚îÇ                ‚îÇ
    ‚îÇ‚îÄ‚îÄ API Request ‚Üí‚îÇ                ‚îÇ
    ‚îÇ (Auto cookie)  ‚îÇ‚Üê Verify JWT ‚îÄ‚îÄ>‚îÇ
    ‚îÇ                ‚îÇ‚Üê Check RBAC ‚îÄ‚îÄ>‚îÇ
    ‚îÇ‚Üê‚îÄ‚îÄ Response ‚îÄ‚îÄ‚îÄ‚îÇ                ‚îÇ
*/

// ###################### WHY BEARER TOKENS? ##############################

/*
Bearer Token Standard: Authorization: Bearer <token>

Why use "Bearer" prefix?
1. Standard Convention - RFC 6750
2. Clear Identification - Differentiates from other auth schemes
3. Security Best Practice - Prevents confusion with other token types
4. Framework Compatibility - Understood by all modern frameworks

Examples of other schemes:
‚Ä¢ Basic: Authorization: Basic base64(username:password)
‚Ä¢ Digest: More secure than Basic
‚Ä¢ API Key: Authorization: Api-Key xxx
*/

// ###################### COOKIES VS LOCALSTORAGE ##############################

/*
Security Comparison:

HTTP-Only Cookies (Recommended):
‚úÖ Automatic sending with requests
‚úÖ Protected from XSS (JavaScript can't access)
‚úÖ Secure, SameSite options available
‚úÖ Proper expiration management
‚ùå Requires CSRF protection
‚ùå Slightly more complex setup

LocalStorage (Not Recommended for tokens):
‚úÖ Simple to implement
‚úÖ Large storage capacity
‚ùå Vulnerable to XSS attacks
‚ùå Manual token attachment required
‚ùå No built-in security features

Best Practice: Use HTTP-only cookies for tokens in production.`
    },
    {
        tabTitle: "JWT Deep Dive",
        title: "JWT Tokens & Implementation",
        content: `// ###################### JWT DEEP DIVE ##############################

/*
JWT Structure: Header.Payload.Signature

1. Header (Base64Url encoded):
   {
     "alg": "HS256",     // Algorithm
     "typ": "JWT"        // Token type
   }

2. Payload (Base64Url encoded):
   {
     "sub": "1234567890",  // Subject (user ID)
     "name": "John Doe",   // Custom claims
     "role": "admin",      // Custom claims
     "iat": 1516239022,   // Issued at
     "exp": 1516242622    // Expiration time
   }

3. Signature:
   HMACSHA256(
     base64UrlEncode(header) + "." +
     base64UrlEncode(payload),
     secret-key
   )
*/

// ###################### JWT IMPLEMENTATION ##############################

const jwt = require('jsonwebtoken');
const crypto = require('crypto');

// Secure JWT configuration
const JWT_CONFIG = {
    accessTokenSecret: process.env.JWT_ACCESS_SECRET || crypto.randomBytes(64).toString('hex'),
    refreshTokenSecret: process.env.JWT_REFRESH_SECRET || crypto.randomBytes(64).toString('hex'),
    accessTokenExpiry: '15m',    // Short-lived for security
    refreshTokenExpiry: '7d',    // Longer-lived for convenience
    issuer: 'your-app-name',
    audience: 'your-app-users'
};

// Token service with enhanced security
const tokenService = {
    generateAccessToken(payload) {
        return jwt.sign(
            {
                ...payload,
                type: 'access',
                jti: crypto.randomUUID() // Unique token ID for revocation
            },
            JWT_CONFIG.accessTokenSecret,
            {
                expiresIn: JWT_CONFIG.accessTokenExpiry,
                issuer: JWT_CONFIG.issuer,
                audience: JWT_CONFIG.audience
            }
        );
    },

    generateRefreshToken(payload) {
        return jwt.sign(
            {
                ...payload,
                type: 'refresh',
                jti: crypto.randomUUID()
            },
            JWT_CONFIG.refreshTokenSecret,
            {
                expiresIn: JWT_CONFIG.refreshTokenExpiry,
                issuer: JWT_CONFIG.issuer,
                audience: JWT_CONFIG.audience
            }
        );
    },

    verifyAccessToken(token) {
        try {
            return jwt.verify(token, JWT_CONFIG.accessTokenSecret, {
                issuer: JWT_CONFIG.issuer,
                audience: JWT_CONFIG.audience
            });
        } catch (error) {
            if (error.name === 'TokenExpiredError') {
                throw new Error('Access token expired');
            }
            if (error.name === 'JsonWebTokenError') {
                throw new Error('Invalid access token');
            }
            throw new Error('Token verification failed');
        }
    },

    verifyRefreshToken(token) {
        try {
            return jwt.verify(token, JWT_CONFIG.refreshTokenSecret, {
                issuer: JWT_CONFIG.issuer,
                audience: JWT_CONFIG.audience
            });
        } catch (error) {
            throw new Error('Invalid or expired refresh token');
        }
    },

    decodeTokenWithoutVerification(token) {
        // Only for debugging - doesn't verify signature
        return jwt.decode(token);
    }
};

// ###################### PASSWORD SECURITY ##############################

const bcrypt = require('bcryptjs');

const passwordService = {
    async hashPassword(password) {
        const saltRounds = 12; // Modern standard (was 10 previously)
        return await bcrypt.hash(password, saltRounds);
    },

    async verifyPassword(password, hashedPassword) {
        return await bcrypt.compare(password, hashedPassword);
    },

    validatePasswordStrength(password) {
        const minLength = 8;
        const hasUpperCase = /[A-Z]/.test(password);
        const hasLowerCase = /[a-z]/.test(password);
        const hasNumbers = /\d/.test(password);
        const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);

        if (password.length < minLength) {
            throw new Error('Password must be at least 8 characters long');
        }
        if (!hasUpperCase || !hasLowerCase) {
            throw new Error('Password must contain both uppercase and lowercase letters');
        }
        if (!hasNumbers) {
            throw new Error('Password must contain at least one number');
        }
        if (!hasSpecialChar) {
            throw new Error('Password must contain at least one special character');
        }

        return true;
    }
};

// ###################### TOKEN TYPES & USAGE ##############################

/*
Access Token:
‚Ä¢ Short-lived (15-30 minutes)
‚Ä¢ Contains user identity and permissions
‚Ä¢ Used for API access
‚Ä¢ Sent with every request

Refresh Token:
‚Ä¢ Long-lived (7-30 days)
‚Ä¢ Used only to get new access tokens
‚Ä¢ Stored securely (HTTP-only cookie)
‚Ä¢ Can be revoked if compromised

Why two tokens?
‚Ä¢ Security: Short access tokens limit exposure
‚Ä¢ User Experience: Don't need to login frequently
‚Ä¢ Control: Can revoke refresh tokens without changing password
*/

// Example token payloads
const accessTokenPayload = {
    id: '507f1f77bcf86cd799439011',
    email: 'user@example.com',
    role: 'user',
    permissions: ['read:profile', 'write:posts'],
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + (15 * 60), // 15 minutes
    jti: 'unique-token-id-123',
    type: 'access'
};

const refreshTokenPayload = {
    id: '507f1f77bcf86cd799439011',
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + (7 * 24 * 60 * 60), // 7 days
    jti: 'unique-refresh-token-456',
    type: 'refresh'
};`
    },
    {
        tabTitle: "Cookie Security",
        title: "Secure Cookie Management & Sessions",
        content: `// ###################### COOKIE SECURITY CONFIGURATION ##############################

const cookieParser = require('cookie-parser');

// Initialize cookie parser middleware
app.use(cookieParser());

// Secure cookie configuration
const cookieConfig = {
    httpOnly: true,        // Prevent XSS attacks - JavaScript cannot access
    secure: process.env.NODE_ENV === 'production', // HTTPS only in production
    sameSite: 'strict',    // CSRF protection - 'strict', 'lax', or 'none'
    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days for refresh token
    path: '/',             // Available across the entire app
    domain: process.env.COOKIE_DOMAIN || undefined // Specify domain if needed
};

const accessTokenCookieConfig = {
    ...cookieConfig,
    maxAge: 15 * 60 * 1000 // 15 minutes for access token
};

// ###################### COOKIE ATTRIBUTES EXPLAINED ##############################

/*
httpOnly: true
‚Ä¢ Prevents JavaScript access to cookies
‚Ä¢ Critical for protecting against XSS attacks
‚Ä¢ Cookies can only be sent to server

secure: true (production only)
‚Ä¢ Cookies only sent over HTTPS
‚Ä¢ Prevents man-in-the-middle attacks
‚Ä¢ Always true in production, false in development

sameSite: 'strict'
‚Ä¢ Prevents CSRF attacks
‚Ä¢ 'strict': No cross-site requests
‚Ä¢ 'lax': Allows some safe cross-site requests
‚Ä¢ 'none': Allows all cross-site requests (requires secure: true)

maxAge: milliseconds
‚Ä¢ Automatic cookie expiration
‚Ä¢ Better than 'expires' for modern browsers
‚Ä¢ Automatically cleaned up by browser

path: '/'
‚Ä¢ Which paths can access the cookie
‚Ä¢ '/' means entire domain
‚Ä¢ '/api' would restrict to API routes only
*/

// ###################### COOKIE MANAGEMENT FUNCTIONS ##############################

const cookieService = {
    setAccessToken(res, token) {
        res.cookie('accessToken', token, accessTokenCookieConfig);
    },

    setRefreshToken(res, token) {
        res.cookie('refreshToken', token, cookieConfig);
    },

    clearTokens(res) {
        res.clearCookie('accessToken');
        res.clearCookie('refreshToken');
    },

    getAccessToken(req) {
        return req.cookies.accessToken;
    },

    getRefreshToken(req) {
        return req.cookies.refreshToken;
    },

    // For cross-domain scenarios (microservices)
    setCrossDomainToken(res, token, domain) {
        res.cookie('serviceToken', token, {
            ...cookieConfig,
            domain: domain,
            sameSite: 'none',
            secure: true
        });
    }
};

// ###################### COOKIE-BASED AUTH ENDPOINTS ##############################

// Login endpoint with secure cookies
app.post('/api/auth/login', asyncHandler(async (req, res) => {
    const { email, password } = req.body;

    // Validate input
    if (!email || !password) {
        throw new AppError('Email and password are required', 400);
    }

    // Find user and verify credentials
    const user = await User.findOne({ email }).select('+password');
    if (!user || !(await passwordService.verifyPassword(password, user.password))) {
        throw new AppError('Invalid credentials', 401);
    }

    // Generate tokens
    const tokenPayload = {
        id: user._id,
        email: user.email,
        role: user.role
    };

    const accessToken = tokenService.generateAccessToken(tokenPayload);
    const refreshToken = tokenService.generateRefreshToken(tokenPayload);

    // Store refresh token in database for rotation
    await RefreshToken.create({
        token: refreshToken,
        userId: user._id,
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
    });

    // Set secure cookies
    cookieService.setAccessToken(res, accessToken);
    cookieService.setRefreshToken(res, refreshToken);

    // Update user last login
    user.lastLogin = new Date();
    await user.save();

    res.json({
        success: true,
        data: {
            user: {
                id: user._id,
                email: user.email,
                name: user.name,
                role: user.role
            }
        }
    });
}));

// Logout endpoint with token cleanup
app.post('/api/auth/logout', asyncHandler(async (req, res) => {
    const refreshToken = cookieService.getRefreshToken(req);

    // Revoke refresh token from database
    if (refreshToken) {
        await RefreshToken.findOneAndUpdate(
            { token: refreshToken },
            { isRevoked: true, revokedAt: new Date() }
        );
    }

    // Clear cookies
    cookieService.clearTokens(res);

    res.json({
        success: true,
        message: 'Logged out successfully'
    });
}));

// Refresh token endpoint
app.post('/api/auth/refresh', asyncHandler(async (req, res) => {
    const refreshToken = cookieService.getRefreshToken(req);
    
    if (!refreshToken) {
        throw new AppError('Refresh token required', 401);
    }

    // Verify refresh token and check database
    const decoded = tokenService.verifyRefreshToken(refreshToken);
    const storedToken = await RefreshToken.findOne({ 
        token: refreshToken, 
        userId: decoded.id 
    });

    if (!storedToken || storedToken.isRevoked) {
        throw new AppError('Invalid refresh token', 401);
    }

    // Generate new tokens
    const tokenPayload = {
        id: decoded.id,
        email: decoded.email,
        role: decoded.role
    };

    const newAccessToken = tokenService.generateAccessToken(tokenPayload);
    const newRefreshToken = tokenService.generateRefreshToken(tokenPayload);

    // Token rotation: revoke old, store new
    await RefreshToken.findByIdAndUpdate(storedToken._id, { 
        isRevoked: true,
        revokedAt: new Date()
    });
    
    await RefreshToken.create({
        token: newRefreshToken,
        userId: decoded.id,
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
    });

    // Set new cookies
    cookieService.setAccessToken(res, newAccessToken);
    cookieService.setRefreshToken(res, newRefreshToken);

    res.json({
        success: true,
        message: 'Tokens refreshed successfully'
    });
}));

// ###################### CSRF PROTECTION ##############################

/*
Since we're using SameSite cookies, CSRF risk is reduced.
For additional protection, consider:

1. CSRF Tokens:
   const csrf = require('csurf');
   app.use(csrf({ cookie: true }));

2. Double Submit Cookie Pattern:
   - Server sends CSRF token in separate cookie
   - Client includes token in header for state-changing requests

3. Additional Headers:
   app.use((req, res, next) => {
     res.setHeader('X-Content-Type-Options', 'nosniff');
     res.setHeader('X-Frame-Options', 'DENY');
     res.setHeader('X-XSS-Protection', '1; mode=block');
     next();
   });
*/

// ###################### COOKIE SECURITY AUDIT ##############################

const cookieSecurity = {
    auditCookies(req) {
        const cookies = req.cookies;
        const securityReport = {};

        for (const [name, value] of Object.entries(cookies)) {
            securityReport[name] = {
                hasHttpOnly: false, // We can't detect this from server-side
                hasSecure: req.secure, // Assuming secure cookies only sent over HTTPS
                length: value.length,
                isJWT: value.split('.').length === 3 // Basic JWT detection
            };
        }

        return securityReport;
    },

    validateCookieSecurity(res) {
        // In real implementation, you'd check response headers
        const securityHeaders = res.getHeaders();
        return {
            hasSecureFlag: securityHeaders['set-cookie']?.some(cookie => cookie.includes('Secure')),
            hasHttpOnly: securityHeaders['set-cookie']?.some(cookie => cookie.includes('HttpOnly')),
            hasSameSite: securityHeaders['set-cookie']?.some(cookie => cookie.includes('SameSite'))
        };
    }
};`
    },
    {
        tabTitle: "Auth Middleware",
        title: "Authentication Middleware & Authorization",
        content: `// ###################### AUTHENTICATION MIDDLEWARE ##############################

// Main authentication middleware
const authenticateToken = asyncHandler(async (req, res, next) => {
    // Get token from cookie (preferred) or Authorization header
    const token = req.cookies.accessToken || 
                 req.headers.authorization?.replace('Bearer ', '');

    if (!token) {
        throw new AppError('Access token required', 401);
    }

    try {
        const decoded = tokenService.verifyAccessToken(token);
        
        // Optional: Verify user still exists and is active
        const user = await User.findById(decoded.id).select('-password');
        if (!user) {
            throw new AppError('User no longer exists', 401);
        }
        
        if (user.isSuspended) {
            throw new AppError('Account suspended', 403);
        }

        // Attach user to request object
        req.user = {
            id: user._id,
            email: user.email,
            role: user.role,
            permissions: user.permissions,
            isVerified: user.isVerified
        };

        next();
    } catch (error) {
        if (error.name === 'TokenExpiredError') {
            throw new AppError('Access token expired', 401);
        }
        throw new AppError('Invalid access token', 401);
    }
});

// Optional authentication (user might be logged in)
const optionalAuth = asyncHandler(async (req, res, next) => {
    const token = req.cookies.accessToken || 
                 req.headers.authorization?.replace('Bearer ', '');

    if (token) {
        try {
            const decoded = tokenService.verifyAccessToken(token);
            const user = await User.findById(decoded.id).select('-password');
            
            if (user && !user.isSuspended) {
                req.user = {
                    id: user._id,
                    email: user.email,
                    role: user.role,
                    permissions: user.permissions
                };
            }
        } catch (error) {
            // Silently fail for optional auth
        }
    }

    next();
});

// ###################### AUTHORIZATION MIDDLEWARE ##############################

// Role-based authorization
const authorize = (...allowedRoles) => {
    return (req, res, next) => {
        if (!req.user) {
            throw new AppError('Authentication required', 401);
        }

        if (!allowedRoles.includes(req.user.role)) {
            throw new AppError('Insufficient permissions', 403);
        }

        next();
    };
};

// Permission-based authorization
const requirePermission = (permission) => {
    return asyncHandler(async (req, res, next) => {
        if (!req.user) {
            throw new AppError('Authentication required', 401);
        }

        // Check user permissions (you might fetch from database)
        const userPermissions = req.user.permissions || [];
        
        if (!userPermissions.includes(permission)) {
            throw new AppError('Insufficient permissions', 403);
        }

        next();
    });
};

// Resource ownership check
const checkResourceOwnership = (model, paramName = 'id') => {
    return asyncHandler(async (req, res, next) => {
        if (!req.user) {
            throw new AppError('Authentication required', 401);
        }

        const resourceId = req.params[paramName];
        const resource = await model.findById(resourceId);

        if (!resource) {
            throw new AppError('Resource not found', 404);
        }

        // Check if user owns resource or is admin
        const isOwner = resource.userId && resource.userId.toString() === req.user.id;
        const isAdmin = req.user.role === 'admin' || req.user.role === 'superadmin';

        if (!isOwner && !isAdmin) {
            throw new AppError('Access denied to this resource', 403);
        }

        req.resource = resource;
        next();
    });
};

// ###################### COMPOSITE MIDDLEWARE EXAMPLES ##############################

// Admin-only middleware (composition of auth + role check)
const requireAdmin = [authenticateToken, authorize('admin', 'superadmin')];

// Verified user middleware
const requireVerifiedUser = [
    authenticateToken,
    (req, res, next) => {
        if (!req.user.isVerified) {
            throw new AppError('Please verify your email address', 403);
        }
        next();
    }
];

// Self or admin middleware (users can access their own data)
const requireSelfOrAdmin = (paramName = 'id') => {
    return [
        authenticateToken,
        (req, res, next) => {
            const targetUserId = req.params[paramName];
            const isSelf = targetUserId === req.user.id;
            const isAdmin = ['admin', 'superadmin'].includes(req.user.role);

            if (!isSelf && !isAdmin) {
                throw new AppError('Access denied', 403);
            }
            next();
        }
    ];
};

// ###################### ROUTE IMPLEMENTATIONS ##############################

// Public route (no auth required)
app.get('/api/public/data', (req, res) => {
    res.json({ message: 'This is public data' });
});

// Protected route (auth required)
app.get('/api/profile', authenticateToken, asyncHandler(async (req, res) => {
    const user = await User.findById(req.user.id).select('-password');
    res.json({
        success: true,
        data: { user }
    });
}));

// Admin-only route
app.get('/api/admin/users', 
    requireAdmin, // Composite middleware
    asyncHandler(async (req, res) => {
        const users = await User.find().select('-password');
        res.json({
            success: true,
            data: { users }
        });
    })
);

// User can access their own data, admin can access any
app.get('/api/users/:userId', 
    requireSelfOrAdmin('userId'),
    asyncHandler(async (req, res) => {
        const user = await User.findById(req.params.userId).select('-password');
        res.json({
            success: true,
            data: { user }
        });
    })
);

// Resource ownership example (user can only update their own posts)
app.put('/api/posts/:postId',
    [authenticateToken, checkResourceOwnership(Post, 'postId')],
    asyncHandler(async (req, res) => {
        const updatedPost = await Post.findByIdAndUpdate(
            req.params.postId,
            req.body,
            { new: true, runValidators: true }
        );
        
        res.json({
            success: true,
            data: { post: updatedPost }
        });
    })
);

// Permission-based route
app.delete('/api/users/:userId',
    [authenticateToken, requirePermission('users:delete')],
    asyncHandler(async (req, res) => {
        await User.findByIdAndDelete(req.params.userId);
        res.json({
            success: true,
            message: 'User deleted successfully'
        });
    })
);

// ###################### ERROR HANDLING FOR AUTH ##############################

// Custom error classes for auth
class AuthenticationError extends AppError {
    constructor(message = 'Authentication failed') {
        super(message, 401);
    }
}

class AuthorizationError extends AppError {
    constructor(message = 'Insufficient permissions') {
        super(message, 403);
    }
}

class TokenExpiredError extends AppError {
    constructor(message = 'Token expired') {
        super(message, 401);
    }
}

// Enhanced global error handler for auth errors
app.use((err, req, res, next) => {
    // Handle JWT errors
    if (err.name === 'JsonWebTokenError') {
        err = new AuthenticationError('Invalid token');
    }
    if (err.name === 'TokenExpiredError') {
        err = new TokenExpiredError('Token expired');
    }

    // Handle mongoose validation errors for auth
    if (err.name === 'ValidationError') {
        const messages = Object.values(err.errors).map(val => val.message);
        err = new AppError(messages.join(', '), 400);
    }

    // Handle duplicate key errors (registration)
    if (err.code === 11000) {
        const field = Object.keys(err.keyValue)[0];
        err = new AppError(\`\${field} already exists\`, 409);
    }

    // Pass to default error handler
    next(err);
});`
    },
    {
        tabTitle: "Security Practices",
        title: "Advanced Security & Best Practices",
        content: `// ###################### SECURITY BEST PRACTICES ##############################

/*
MODERN SECURITY MEASURES:

1. Password Security:
   - Minimum 8 characters with complexity requirements
   - Breached password detection (Have I Been Pwned)
   - Regular password rotation policies
   - Secure password reset flows

2. Token Security:
   - Short-lived access tokens (15-30 minutes)
   - Long-lived refresh tokens (7 days) with rotation
   - Token blacklisting/revocation capabilities
   - Secure storage (HTTP-only, Secure, SameSite cookies)

3. Rate Limiting:
   - Stricter limits on authentication endpoints
   - Account lockout after failed attempts
   - IP-based and user-based rate limiting
*/

// ###################### ENHANCED RATE LIMITING ##############################

const rateLimit = require('express-rate-limit');

// General API rate limiting
const apiLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Limit each IP to 100 requests per windowMs
    message: {
        error: 'Too many requests from this IP, please try again later.'
    },
    standardHeaders: true,
    legacyHeaders: false
});

// Stricter limits for auth endpoints
const authLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 5, // 5 attempts per window for sensitive endpoints
    message: {
        error: 'Too many authentication attempts, please try again later.'
    },
    skipSuccessfulRequests: true, // Only count failed attempts
    keyGenerator: (req) => {
        // Use IP + user agent for more precise limiting
        return \`\${req.ip}-\${req.get('User-Agent')}\`;
    }
});

// Bruteforce protection for login
const loginLimiter = rateLimit({
    windowMs: 60 * 60 * 1000, // 1 hour
    max: 10, // Max 10 failed attempts per hour
    skipSuccessfulRequests: true,
    handler: (req, res) => {
        // Log security event
        console.warn(\`Bruteforce attempt detected from IP: \${req.ip}\`);
        res.status(429).json({
            error: 'Too many failed login attempts. Please try again in an hour.'
        });
    }
});

// Apply rate limiting
app.use('/api/', apiLimiter);
app.use('/api/auth/login', [authLimiter, loginLimiter]);
app.use('/api/auth/register', authLimiter);
app.use('/api/auth/forgot-password', authLimiter);

// ###################### ACCOUNT LOCKOUT MECHANISM ##############################

const accountLockout = {
    async handleFailedLogin(userId) {
        const user = await User.findById(userId);
        if (!user) return;

        user.failedLoginAttempts = (user.failedLoginAttempts || 0) + 1;
        
        // Lock account after 5 failed attempts
        if (user.failedLoginAttempts >= 5) {
            user.isLocked = true;
            user.lockedUntil = new Date(Date.now() + 30 * 60 * 1000); // 30 minutes
        }

        await user.save();
    },

    async resetFailedAttempts(userId) {
        await User.findByIdAndUpdate(userId, {
            failedLoginAttempts: 0,
            isLocked: false,
            lockedUntil: null
        });
    },

    async isAccountLocked(userId) {
        const user = await User.findById(userId);
        if (!user) return false;

        // Check if lock period has expired
        if (user.lockedUntil && user.lockedUntil > new Date()) {
            return true;
        }

        // Auto-unlock if lock period expired
        if (user.isLocked && user.lockedUntil && user.lockedUntil <= new Date()) {
            user.isLocked = false;
            user.lockedUntil = null;
            user.failedLoginAttempts = 0;
            await user.save();
            return false;
        }

        return user.isLocked;
    }
};

// ###################### PASSWORD SECURITY ENHANCEMENTS ##############################

const passwordPolicy = {
    async isPasswordBreached(password) {
        // In production, integrate with Have I Been Pwned API
        // This is a simplified version
        const breachedPasswords = ['password123', '12345678', 'qwerty'];
        return breachedPasswords.includes(password);
    },

    validatePasswordHistory(userId, newPassword) {
        // Check if password was used before (simplified)
        // In reality, you'd check against previously hashed passwords
        return false;
    },

    generatePasswordRequirements() {
        return {
            minLength: 8,
            requireUppercase: true,
            requireLowercase: true,
            requireNumbers: true,
            requireSpecialChars: true,
            maxAge: 90 // days until password expiry
        };
    }
};

// ###################### SECURITY HEADERS ENHANCEMENT ##############################

// Enhanced security headers specifically for auth
app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
            scriptSrc: ["'self'", "'unsafe-inline'"],
            imgSrc: ["'self'", "data:", "https:"],
            connectSrc: ["'self'", "https://api.yourdomain.com"],
            fontSrc: ["'self'", "https://fonts.gstatic.com"],
            frameAncestors: ["'none'"], // Prevent clickjacking
            formAction: ["'self'"] // Restrict form submissions
        },
    },
    crossOriginEmbedderPolicy: false,
    hsts: {
        maxAge: 31536000, // 1 year
        includeSubDomains: true,
        preload: true
    },
    referrerPolicy: { policy: 'strict-origin-when-cross-origin' }
}));

// Additional security headers
app.use((req, res, next) => {
    // Prevent MIME type sniffing
    res.setHeader('X-Content-Type-Options', 'nosniff');
    
    // Prevent clickjacking
    res.setHeader('X-Frame-Options', 'DENY');
    
    // Enable XSS filter
    res.setHeader('X-XSS-Protection', '1; mode=block');
    
    // Remove server information
    res.removeHeader('X-Powered-By');
    
    next();
});

// ###################### SECURITY MONITORING & AUDITING ##############################

const securityLogger = {
    logAuthAttempt(email, success, ip, userAgent) {
        const logEntry = {
            timestamp: new Date(),
            event: success ? 'LOGIN_SUCCESS' : 'LOGIN_FAILED',
            email: success ? email : undefined, // Don't log failed emails for privacy
            ip,
            userAgent: userAgent?.substring(0, 100), // Limit length
            success
        };

        console.log('AUTH_ATTEMPT:', logEntry);
        
        // In production, send to security monitoring service
        // await SecurityLog.create(logEntry);
    },

    logTokenRefresh(userId, success) {
        console.log(\`TOKEN_REFRESH: user=\${userId} success=\${success}\`);
    },

    logSecurityEvent(event, details) {
        const securityEvent = {
            timestamp: new Date(),
            event,
            ...details
        };

        console.warn('SECURITY_EVENT:', securityEvent);
    }
};

// ###################### PRODUCTION SECURITY CHECKLIST ##############################

/*
‚úÖ Environment Variables:
   - JWT secrets set and strong
   - Database credentials secure
   - API keys not in code

‚úÖ HTTPS Enforcement:
   - SSL certificate valid
   - HTTP to HTTPS redirect
   - HSTS headers enabled

‚úÖ Cookie Security:
   - HTTP-only flag set
   - Secure flag in production
   - SameSite policy configured
   - Proper domain and path settings

‚úÖ Rate Limiting:
   - Authentication endpoints protected
   - API endpoints limited
   - Bruteforce protection enabled

‚úÖ Input Validation:
   - Request body validation
   - SQL injection prevention
   - XSS protection

‚úÖ Error Handling:
   - No sensitive data in errors
   - Proper logging
   - Generic error messages in production

‚úÖ Dependency Security:
   - Regular dependency updates
   - Security audits
   - Vulnerability monitoring

‚úÖ Monitoring:
   - Failed login attempts logged
   - Suspicious activity detection
   - Regular security audits
*/

// ###################### REGULAR SECURITY AUDITS ##############################

const securityAudit = {
    async runSecurityCheck() {
        const checks = {
            weakPasswords: await this.checkWeakPasswords(),
            expiredTokens: await this.cleanExpiredTokens(),
            oldSessions: await this.checkOldSessions(),
            adminUsers: await this.auditAdminUsers()
        };

        return checks;
    },

    async checkWeakPasswords() {
        // Check for users with weak passwords (simplified)
        // In reality, you'd check password strength
        return { checked: true, issues: [] };
    },

    async cleanExpiredTokens() {
        // Clean up expired refresh tokens
        const result = await RefreshToken.deleteMany({
            expiresAt: { $lt: new Date() }
        });
        return \`Cleaned \${result.deletedCount} expired tokens\`;
    },

    async checkOldSessions() {
        // Check for suspiciously long sessions
        const oldSessions = await RefreshToken.find({
            createdAt: { $lt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) } // 30 days
        });
        return oldSessions.length;
    },

    async auditAdminUsers() {
        // Audit admin users and their activity
        const adminUsers = await User.find({ role: { $in: ['admin', 'superadmin'] } });
        return adminUsers.map(user => ({
            id: user._id,
            email: user.email,
            lastLogin: user.lastLogin
        }));
    }
};`
    },{
        tabTitle: "Advanced Express",
        title: "Production-Ready Express Applications",
        content: `/*
Production Best Practices:
‚Ä¢ Environment configuration
‚Ä¢ Security headers
‚Ä¢ Rate limiting
‚Ä¢ Request sanitization
‚Ä¢ Proper error handling
‚Ä¢ Logging
‚Ä¢ Performance optimization
*/

const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const compression = require('compression');

// Security middleware
app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            scriptSrc: ["'self'"],
            imgSrc: ["'self'", "data:", "https:"],
        },
    },
    crossOriginEmbedderPolicy: false
}));

// CORS configuration
app.use(cors({
    origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
    credentials: true
}));

// Rate limiting
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // limit each IP to 100 requests per windowMs
    message: {
        error: 'Too many requests from this IP, please try again later.'
    }
});
app.use('/api/', limiter);

// Compression
app.use(compression());

// Environment-based configuration
const config = {
    development: {
        port: 4000,
        host: 'localhost',
        logLevel: 'debug'
    },
    production: {
        port: process.env.PORT || 80,
        host: '0.0.0.0',
        logLevel: 'warn'
    }
};

const environment = process.env.NODE_ENV || 'development';
const currentConfig = config[environment];

// Advanced error handling
class AppError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.statusCode = statusCode;
        this.isOperational = true;
        Error.captureStackTrace(this, this.constructor);
    }
}

// Async error wrapper (avoid try-catch in every route)
const asyncHandler = (fn) => (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
};

// Example with async handler
app.get('/api/async-users', asyncHandler(async (req, res) => {
    // Simulate async operation
    const users = await Promise.resolve([...users]);
    res.json({ success: true, data: users });
}));

// Global error handler
app.use((err, req, res, next) => {
    err.statusCode = err.statusCode || 500;
    err.status = err.status || 'error';

    if (process.env.NODE_ENV === 'development') {
        res.status(err.statusCode).json({
            status: err.status,
            error: err,
            message: err.message,
            stack: err.stack
        });
    } else {
        // Production: don't leak error details
        if (err.isOperational) {
            res.status(err.statusCode).json({
                status: err.status,
                message: err.message
            });
        } else {
            console.error('ERROR üí•', err);
            res.status(500).json({
                status: 'error',
                message: 'Something went wrong!'
            });
        }
    }
});

// Graceful shutdown
process.on('SIGTERM', () => {
    console.log('SIGTERM received. Shutting down gracefully...');
    server.close(() => {
        console.log('Process terminated');
    });
});`
    },
        ];

// Updated Questions array aligned with the new topics
const questions = [
    // MongoDB Setup
    {
        type: "question",
        question: "What is the main advantage of using MongoDB Atlas over local MongoDB installation?",
        options: [
            "It's always free with unlimited storage",
            "It provides automated backups, scaling, and managed infrastructure",
            "It doesn't require any configuration",
            "It only works with JavaScript applications"
        ],
        correctIndex: 1
    },
    {
        type: "question",
        question: "Which connection string format is used for MongoDB Atlas clusters?",
        options: [
            "mongodb://localhost:27017",
            "mysql://username:password@host:port/database",
            "mongodb+srv://username:password@cluster.mongodb.net/database",
            "postgresql://user:pass@host/db"
        ],
        correctIndex: 2
    },

    // MongoDB Compass
    {
        type: "question",
        question: "What is the primary purpose of MongoDB Compass?",
        options: [
            "To write Node.js application code",
            "To provide a graphical interface for database management and query building",
            "To deploy applications to production servers",
            "To monitor server CPU and memory usage"
        ],
        correctIndex: 1
    },
    {
        type: "question",
        question: "Which feature in MongoDB Compass allows you to visually build aggregation pipelines?",
        options: [
            "Document Validation",
            "Aggregation Pipeline Builder", 
            "Index Manager",
            "Schema Analyzer"
        ],
        correctIndex: 1
    },

    // Mongoose Basics
    {
        type: "question",
        question: "What is Mongoose in the context of Node.js and MongoDB?",
        options: [
            "A template engine for rendering HTML",
            "An Object Data Modeling (ODM) library that provides schema-based solution",
            "A testing framework for JavaScript applications",
            "A package manager for Node.js"
        ],
        correctIndex: 1
    },
    {
        type: "question",
        question: "Which Mongoose connection option controls the maximum number of sockets in the connection pool?",
        options: [
            "socketTimeoutMS",
            "maxPoolSize",
            "connectTimeoutMS", 
            "serverSelectionTimeoutMS"
        ],
        correctIndex: 1
    },

    // Mongoose Schemas
    {
        type: "question",
        question: "What is the purpose of the 'timestamps' option in a Mongoose schema?",
        options: [
            "It automatically adds createdAt and updatedAt fields to documents",
            "It creates indexes on all date fields",
            "It validates that all dates are in the correct format",
            "It converts all dates to UTC timezone"
        ],
        correctIndex: 0
    },
    {
        type: "question",
        question: "Which Mongoose feature allows you to create properties that are computed from other fields but not stored in the database?",
        options: [
            "Instance methods",
            "Static methods",
            "Virtual properties",
            "Middleware hooks"
        ],
        correctIndex: 2
    },
    {
        type: "question",
        question: "What is the main purpose of Mongoose middleware (pre and post hooks)?",
        options: [
            "To create database indexes automatically",
            "To execute logic before or after specific operations like save, find, etc.",
            "To generate API documentation from schemas",
            "To optimize database queries for better performance"
        ],
        correctIndex: 1
    },

    // Mongoose CRUD
    {
        type: "question",
        question: "What is the difference between findOne() and findById() in Mongoose?",
        options: [
            "findOne() is faster than findById()",
            "findById() specifically searches by the _id field while findOne() can search by any field",
            "findOne() returns an array while findById() returns a single document",
            "There is no difference, they are aliases for the same method"
        ],
        correctIndex: 1
    },
    {
        type: "question",
        question: "Which method is used to update a document and return the updated version in a single operation?",
        options: [
            "updateOne()",
            "updateMany()",
            "findOneAndUpdate() with {new: true}",
            "save() after modification"
        ],
        correctIndex: 2
    },
    {
        type: "question",
        question: "What is the purpose of the populate() method in Mongoose?",
        options: [
            "To fill a collection with sample data for testing",
            "To replace document references with actual documents from other collections",
            "To increase database performance by caching queries",
            "To validate all documents in a collection"
        ],
        correctIndex: 1
    },

    // Advanced Mongoose
    {
        type: "question",
        question: "What are Mongoose discriminators used for?",
        options: [
            "To distinguish between different error types",
            "To create schema inheritance and model different types of documents in the same collection",
            "To discriminate between valid and invalid queries",
            "To create different database connections for different environments"
        ],
        correctIndex: 1
    },
    {
        type: "question",
        question: "Which Mongoose feature allows you to group multiple database operations into a single atomic transaction?",
        options: [
            "Aggregation pipelines",
            "Middleware hooks",
            "Sessions with transactions",
            "Query builders"
        ],
        correctIndex: 2
    },
    {
        type: "question",
        question: "What is the purpose of the lean() method in Mongoose queries?",
        options: [
            "To make queries run faster by returning plain JavaScript objects instead of Mongoose documents",
            "To reduce the memory usage of the Node.js application",
            "To remove all validation from the query results",
            "To automatically remove sensitive fields from returned documents"
        ],
        correctIndex: 0
    },

    // Advanced Express
    {
        type: "question",
        question: "What is the main purpose of the Helmet.js middleware in Express applications?",
        options: [
            "To compress response bodies",
            "To set various HTTP headers for security protection",
            "To rate limit incoming requests",
            "To handle CORS configuration"
        ],
        correctIndex: 1
    },
    {
        type: "question",
        question: "In Express error handling, what is the advantage of using asyncHandler?",
        options: [
            "It makes all routes run asynchronously by default",
            "It automatically catches both synchronous and asynchronous errors in route handlers",
            "It converts callback-based functions to promise-based ones",
            "It adds retry logic for failed database operations"
        ],
        correctIndex: 1
    },

    // Practical Tasks - MongoDB & Tools
    {
        type: "task",
        title: "MongoDB Atlas Cluster Setup",
        content: "Create a MongoDB Atlas cluster, configure database access with proper security settings, set up network access rules, and test the connection. Create separate database users for development and production environments."
    },
    {
        type: "task",
        title: "MongoDB Compass Mastery",
        content: "Use MongoDB Compass to explore your database, create and edit documents visually, build complex queries using the GUI, analyze query performance, create indexes, and use the aggregation pipeline builder. Export your database schema analysis."
    },

    // Practical Tasks - Mongoose Basics
    {
        type: "task",
        title: "Mongoose Connection Management",
        content: "Implement a robust database connection module with connection pooling, proper error handling, reconnection logic, and graceful shutdown. Add connection state monitoring and environment-specific configurations."
    },
    {
        type: "task", 
        title: "Advanced Schema Design",
        content: "Design and implement comprehensive Mongoose schemas for a social media application including users, posts, comments, and reactions. Add proper validation, virtual properties, instance/static methods, and middleware hooks."
    },

    // Practical Tasks - Mongoose CRUD
    {
        type: "task",
        title: "Complete CRUD API Implementation",
        content: "Build a complete REST API with full CRUD operations using Mongoose. Implement filtering, sorting, pagination, population of related data, and proper error handling. Add transaction support for complex operations."
    },
    {
        type: "task",
        title: "Advanced Query Building",
        content: "Create advanced Mongoose queries including aggregation pipelines, text search, geospatial queries, and complex filtering. Implement query performance optimization and indexing strategies."
    },

    // Practical Tasks - Advanced Mongoose
    {
        type: "task",
        title: "Mongoose Plugins & Middleware",
        content: "Create reusable Mongoose plugins for common functionality like soft delete, audit logging, and data encryption. Implement advanced middleware patterns for cross-cutting concerns."
    },
    {
        type: "task",
        title: "Database Transactions & Change Streams",
        content: "Implement complex database transactions for multi-document operations and set up change streams for real-time data updates. Create proper error handling and rollback mechanisms."
    },

    // Search & Research Tasks
    {
        type: "search-task",
        title: "Research: Mongoose Performance Optimization",
        content: "Research and document Mongoose performance optimization techniques including connection pooling, query optimization, indexing strategies, and memory management. Create performance benchmarks for different query patterns."
    },
    {
        type: "search-task", 
        title: "Research: MongoDB Best Practices",
        content: "Research MongoDB best practices for schema design, indexing, aggregation pipelines, and data modeling. Compare different approaches for common use cases and create implementation guidelines."
    },

    // Integration & Production Tasks
    {
        type: "task",
        title: "Full Stack Application Integration",
        content: "Build a complete full-stack application integrating Express.js, Mongoose, and MongoDB Atlas. Implement user authentication, real-time features, proper error handling, and production-ready configurations."
    },
    {
        type: "task",
        title: "Production Deployment & Monitoring",
        content: "Prepare your Mongoose/Express application for production deployment. Configure environment variables, set up monitoring, implement health checks, create backup strategies, and set up performance monitoring."
    }
];    // Set lecture title and subtitle
        document.getElementById('lecture-title').textContent = lectureConfig.title;
        document.getElementById('lecture-subtitle').textContent = lectureConfig.subtitle;
        
        // Render tabs and content
        function renderTabsAndContent() {
            const tabsContainer = document.getElementById('tabs-container');
            const contentContainer = document.getElementById('tab-content-container');
            
            // Create tabs
            const tabs = document.createElement('div');
            tabs.className = 'tabs';
            
            // Create tab content areas
            lectureContent.forEach((content, index) => {
                // Create tab
                const tab = document.createElement('div');
                tab.className = 'tab' + (index === 0 ? ' active' : '');
                tab.textContent = content.tabTitle;
                tab.onclick = () => switchTab(index);
                tabs.appendChild(tab);
                
                // Create content
                const tabContent = document.createElement('div');
                tabContent.className = 'tab-content' + (index === 0 ? ' active' : '');
                tabContent.id = 'tab-' + index;
                
                // Add title
                const title = document.createElement('h3');
                title.textContent = content.title;
                tabContent.appendChild(title);
                
                // Add code content
                const pre = document.createElement('pre');
                const code = document.createElement('code');
                code.textContent = content.content;
                pre.appendChild(code);
                tabContent.appendChild(pre);

                // Add table if exists
                if (content.table) {
                    const table = document.createElement('table');
                    table.className = 'comparison-table';
                    
                    // Create header
                    const thead = document.createElement('thead');
                    const headerRow = document.createElement('tr');
                    content.table.headers.forEach(headerText => {
                        const th = document.createElement('th');
                        th.textContent = headerText;
                        headerRow.appendChild(th);
                    });
                    thead.appendChild(headerRow);
                    table.appendChild(thead);
                    
                    // Create body
                    const tbody = document.createElement('tbody');
                    content.table.rows.forEach(rowData => {
                        const row = document.createElement('tr');
                        rowData.forEach(cellData => {
                            const td = document.createElement('td');
                            td.textContent = cellData;
                            row.appendChild(td);
                        });
                        tbody.appendChild(row);
                    });
                    table.appendChild(tbody);
                    
                    tabContent.appendChild(table);
                }
                
                
                contentContainer.appendChild(tabContent);
            });
            
            tabsContainer.appendChild(tabs);
        }
        
        // Switch tabs function
        function switchTab(index) {
            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Add active class to clicked tab
            tabs[index].classList.add('active');
            
            // Hide all tab content
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => content.classList.remove('active'));
            
            // Show selected tab content
            document.getElementById('tab-' + index).classList.add('active');
        }
        
        // Render questions and tasks
        function renderQuestions() {
            const container = document.getElementById('questions-container');
            
            questions.forEach((q, index) => {
                if (q.type === 'question') {
                    const questionDiv = document.createElement('div');
                    questionDiv.className = 'question';
                    
                    const questionTitle = document.createElement('h3');
                    questionTitle.textContent = `Question ${index + 1}: ${q.question}`;
                    questionDiv.appendChild(questionTitle);
                    
                    if (q.code) {
                        const pre = document.createElement('pre');
                        const code = document.createElement('code');
                        code.textContent = q.code;
                        pre.appendChild(code);
                        questionDiv.appendChild(pre);
                    }
                    
                    const optionsDiv = document.createElement('div');
                    optionsDiv.className = 'options';
                    
                    q.options.forEach((option, optIndex) => {
                        const optionDiv = document.createElement('div');
                        optionDiv.className = 'option';
                        optionDiv.textContent = option;
                        optionDiv.onclick = function() {
                            checkAnswer(this, optIndex === q.correctIndex ? 'correct' : 'incorrect');
                        };
                        optionsDiv.appendChild(optionDiv);
                    });
                    
                    questionDiv.appendChild(optionsDiv);
                    
                    const resultDiv = document.createElement('div');
                    resultDiv.className = 'result';
                    resultDiv.id = 'result-' + index;
                    questionDiv.appendChild(resultDiv);
                    
                    container.appendChild(questionDiv);
                } else if (q.type === 'task') {
                    const taskDiv = document.createElement('div');
                    taskDiv.className = 'task';
                    
                    const taskTitle = document.createElement('h3');
                    taskTitle.textContent = q.title;
                    taskDiv.appendChild(taskTitle);
                    
                    const taskContent = document.createElement('p');
                    taskContent.textContent = q.content;
                    taskDiv.appendChild(taskContent);
                    
                    container.appendChild(taskDiv);
                } else if (q.type === 'search-task') {
                    const searchTaskDiv = document.createElement('div');
                    searchTaskDiv.className = 'search-task';
                    
                    const taskTitle = document.createElement('h3');
                    taskTitle.textContent = q.title;
                    searchTaskDiv.appendChild(taskTitle);
                    
                    const taskContent = document.createElement('p');
                    taskContent.textContent = q.content;
                    searchTaskDiv.appendChild(taskContent);
                    
                    container.appendChild(searchTaskDiv);
                }
            });
        }
        
        // Check answer function
        function checkAnswer(element, type) {
            const options = element.parentElement.querySelectorAll('.option');
            options.forEach(opt => {
                opt.classList.remove('correct', 'incorrect');
                opt.onclick = null;
            });
            
            element.classList.add(type);
            
            const resultId = element.closest('.question').querySelector('.result').id;
            const resultDiv = document.getElementById(resultId);
            resultDiv.style.display = 'block';
            
            if (type === 'correct') {
                resultDiv.innerHTML = '<p style="color: #155724">‚úÖ Correct! Good job.</p>';
                resultDiv.style.backgroundColor = '#d4edda';
            } else {
                resultDiv.innerHTML = '<p style="color: #721c24">‚ùå Incorrect. Try to understand why.</p>';
                resultDiv.style.backgroundColor = '#f8d7da';
            }
        }
        
        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            renderTabsAndContent();
            renderQuestions();
        });
    </script>
</body>
</html>