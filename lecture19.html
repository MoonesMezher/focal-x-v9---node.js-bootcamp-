<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Focal X - Node.js Bootcamp: Lecture 19 </title><link rel="manifest" href="./manifest.json" />
    <link rel="apple-touch-icon" href="./logo.jpg">
    <meta name="apple-mobile-web-app-status-bar" content="#aa7700">
    <meta name="theme-color" content="#b21f1f">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: #333;
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .footer {
            padding-top: 30px;
        }

        .footer a {
            color: black;
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }
        
        .container {
            width: 100%;
            max-width: 1200px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .coach {
            background-color: white;
            width: 80px;
            border-radius: 0 0 50% 0;
            color: black;
            padding: 10px;
            position: absolute;
            left: 0;
            top: 0;
        }
        
        header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
            height: 65vh;
        }
        
        .lecture-content {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }
        
        .interactive-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }
        
        h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
            font-size: 1.5rem;
        }
        
        h3 {
            color: #2980b9;
            margin: 20px 0 12px;
            font-size: 1.2rem;
        }
        
        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 12px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 12px 0;
            font-size: 0.9rem;
        }
        
        code {
            font-family: 'Fira Code', monospace;
        }
        
        .question {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }
        
        .options {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin: 12px 0;
        }
        
        .option {
            padding: 10px;
            background: #e8f4fc;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 0.9rem;
        }
        
        .option:hover {
            background: #d1e9fa;
        }
        
        .correct {
            background: #d4edda;
            border: 1px solid #c3e6cb;
        }
        
        .incorrect {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
        }
        
        .task {
            background: #fff3cd;
            padding: 12px;
            border-left: 5px solid #ffc107;
            margin: 15px 0;
            border-radius: 5px;
            font-size: 0.9rem;
        }
        
        .btn {
            display: inline-block;
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s;
            margin-top: 8px;
        }
        
        .btn:hover {
            background: #2980b9;
        }
        
        .result {
            margin-top: 12px;
            padding: 12px;
            border-radius: 5px;
            display: none;
            font-size: 0.9rem;
        }
        
        .search-task {
            background: #e7f5e9;
            padding: 12px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 5px solid #28a745;
            font-size: 0.9rem;
        }
        
        .tabs {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }
        
        .tab {
            padding: 8px 15px;
            cursor: pointer;
            background: #f1f1f1;
            border: 1px solid #ddd;
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }
        
        .tab.active {
            background: #6f42c1;
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 12px 0;
            font-size: 0.9rem;
        }
        
        .comparison-table th, .comparison-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        
        .comparison-table th {
            background-color: #3498db;
            color: white;
        }
        
        .comparison-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        @media (max-width: 900px) {
            .content {
                grid-template-columns: 1fr;
                height: auto;
            }
            
            .lecture-content, .interactive-section {
                height: 50vh;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <p class="coach">Moones Mezher</p>
        <header>
            <h1 id="lecture-title">Focal X - Node.js Bootcamp</h1>
            <p class="subtitle" id="lecture-subtitle">Node</p>
        </header>
        
        <div class="content">
            <div class="lecture-content">
                <h2>Lecture Content</h2>
                <div id="tabs-container"></div>
                <div id="tab-content-container"></div>
            </div>
            
            <div class="interactive-section">
                <h2>Interactive Questions & Tasks</h2>
                <div id="questions-container"></div>
            </div>
        </div>
    </div>

    <footer class="footer">
        <p>&copy; 2025 <a rel="noopener" href="https://focal-x.com/" target="_blank">Focal X</a> All Right Reserved</p>
    </footer>

        <script src="./reg.js"></script>
<script>
        // ==================== CONFIGURATION ====================
        // Update these arrays to change the content of your lecture
        
        // Lecture metadata
        const lectureConfig = {
            title: "Focal X - Node.js Bootcamp",
            subtitle: "MongoDB & Mongoose"
        };
        
       // Lecture content organized by tabs
const lectureContent = [
    {
        tabTitle: "Last Lesson",
        title: "Last Lesson Recap",
        content: `/*
1- Postman
2- Plop 
3- Database Fundamentals
4- MongoDB
5- MongoDB Setup
*/`
    },
    {
        tabTitle: "MongoDB Setup",
        title: "MongoDB Atlas & Local Installation",
        content: `/*
Option A: MongoDB Atlas (Cloud - Recommended for Production)
1. Create account at https://www.mongodb.com/cloud/atlas
2. Build a Cluster:
   - Choose cloud provider (AWS, Google Cloud, Azure)
   - Select region closest to your users
   - Choose M0 (Free tier) for development
3. Security Configuration:
   - Create database user with read/write privileges
   - Add IP whitelist: 0.0.0.0/0 (all IPs) for development
4. Get Connection String:
mongodb+srv://username:password@cluster0.xzyr.mongodb.net/databaseName?retryWrites=true&w=majority

Option B: Local Installation (Development)
1. Download MongoDB Community Server
2. Installation:
   - Windows: MSI installer with MongoDB Compass
   - macOS: brew install mongodb-community
   - Linux: apt-get install mongodb
3. Start MongoDB service
4. Connect: mongodb://localhost:27017/databaseName

Connection String Options:
• Local: mongodb://localhost:27017/yourDatabase
• Atlas: mongodb+srv://username:password@cluster.mongodb.net/yourDatabase
• With options: mongodb+srv://username:password@cluster.mongodb.net/yourDatabase?retryWrites=true&w=majority&appName=YourAppName
*/`
    },
    {
        tabTitle: "MongoDB Compass",
        title: "MongoDB Compass GUI - Visual Database Management",
        content: `/*
MongoDB Compass Features:
• Visual document explorer and editor
• Query performance analytics
• Index management and optimization
• Schema analysis and validation
• Aggregation pipeline builder
• Import/Export capabilities
• Real-time server statistics
*/

// ## Connecting to Databases with Compass

/*
Supported Connection Types:
1. Local MongoDB: mongodb://localhost:27017
2. MongoDB Atlas: mongodb+srv://username:password@cluster...
3. SSH Tunnel connections
4. TLS/SSL encrypted connections
*/

// ## Key Compass Features in Detail

// 1. Document Visualization and Editing
/*
• Tree and table view of documents
• JSON editor with syntax highlighting
• In-place document editing
• Array and sub-document navigation
*/

// 2. Query Building
/*
• Visual query builder for beginners
• JSON query input for advanced users
• Filter, project, sort, and limit queries
• Save frequently used queries
*/

// 3. Index Management
/*
• View existing indexes
• Create new indexes (single field, compound, unique)
• Analyze index usage and performance
• Drop unused indexes
*/

// 4. Aggregation Pipeline Builder
/*
• Visual aggregation pipeline stages
• Stage-by-stage document preview
• Export aggregation queries to code
• Common pipeline templates
*/

// 5. Schema Analysis
/*
• Automatic schema inference
• Data type frequency analysis
• Schema validation rules generator
• Data distribution insights
*/

// ## Practical Compass Workflow

// Example: User Management in Compass
/*
1. Connect to your database
2. Navigate to 'users' collection
3. Create a new document:
{
  "name": "John Doe",
  "email": "john@example.com",
  "age": 30,
  "createdAt": new Date()
}
4. Run a query: { "age": { "$gte": 25 } }
5. Create an index on email field
6. Analyze the schema of your collection
*/

// ## Import/Export Operations

/*
Import Options:
• JSON files
• CSV files
• BSON files (for backups)

Export Options:
• JSON (canonical, relaxed)
• CSV
• Full database backup
*/

// ## Performance Monitoring

/*
• Real-time operation monitoring
• Slow query identification
• Memory and storage usage
• Connection statistics
*/`
    },
    {
        tabTitle: "Mongoose Basics",
        title: "Mongoose ODM - Fundamentals & Connection",
        content: `// ## What is Mongoose?

/*
Mongoose is an Object Data Modeling (ODM) library for MongoDB and Node.js.
It provides:
• Schema-based solution to model application data
• Built-in type casting, validation, query building
• Business logic hooks
• Easy population of related data
*/

// 1. Installation: npm install mongoose

// 2. Database Connection Configuration
const mongoose = require('mongoose');

// Basic connection
const connectDB = async () => {
    try {
        const conn = await mongoose.connect(process.env.MONGODB_URI, {
            // Connection options (Mongoose 6+)
            maxPoolSize: 10, // Maximum number of sockets in connection pool
            serverSelectionTimeoutMS: 5000, // Timeout for server selection
            socketTimeoutMS: 45000, // Socket timeout
            bufferCommands: false, // Disable mongoose buffering
            bufferMaxEntries: 0, // Disable MongoDB driver buffering
        });

        console.log(\`MongoDB Connected: \${conn.connection.host}\`);
        console.log(\`Database Name: \${conn.connection.name}\`);
    } catch (error) {
        console.error('Database connection error:', error);
        process.exit(1);
    }
};

// Advanced connection configuration for production
const connectDBAdvanced = async () => {
    try {
        const conn = await mongoose.connect(process.env.MONGODB_URI, {
            // Connection pooling
            maxPoolSize: process.env.NODE_ENV === 'production' ? 50 : 10,
            minPoolSize: 5,
            
            // Timeout configurations
            serverSelectionTimeoutMS: 30000,
            socketTimeoutMS: 45000,
            connectTimeoutMS: 30000,
            
            // Write concerns
            w: 'majority',
            journal: true,
            
            // Retry configuration
            retryWrites: true,
            retryReads: true
        });

        console.log(\`MongoDB Connected: \${conn.connection.host}\`);
    } catch (error) {
        console.error('Database connection error:', error);
        process.exit(1);
    }
};

// ## Connection Event Handling

// Modern connection event handling
mongoose.connection.on('connected', () => {
    console.log('Mongoose connected to MongoDB');
});

mongoose.connection.on('error', (err) => {
    console.error('Mongoose connection error:', err);
});

mongoose.connection.on('disconnected', () => {
    console.log('Mongoose disconnected');
});

mongoose.connection.on('reconnected', () => {
    console.log('Mongoose reconnected to MongoDB');
});

// ## Connection States
console.log('Connection state:', mongoose.connection.readyState);
/*
Connection States:
0: disconnected
1: connected
2: connecting
3: disconnecting
*/

// ## Graceful shutdown
process.on('SIGINT', async () => {
    await mongoose.connection.close();
    console.log('MongoDB connection closed due to app termination');
    process.exit(0);
});

process.on('SIGTERM', async () => {
    await mongoose.connection.close();
    console.log('MongoDB connection closed due to app termination');
    process.exit(0);
});

// ## Connection Best Practices

/*
Production Tips:
1. Use environment variables for connection strings
2. Implement connection pooling
3. Handle connection errors gracefully
4. Monitor connection health
5. Use retry logic for initial connections
6. Close connections properly on app shutdown
*/

module.exports = connectDB;`
    },
    {
        tabTitle: "Mongoose Schemas",
        title: "Mongoose Schema Design & Data Modeling",
        content: `// ## Mongoose Schema Fundamentals

/*
What is a Schema?
• Blueprint for documents in a collection
• Defines structure and data types
• Enforces validation rules
• Supports middleware and methods
*/

// Basic Schema Definition
const mongoose = require('mongoose');
const { Schema } = mongoose;

const userSchema = new Schema({
    // String type with validation
    name: { 
        type: String, 
        required: [true, 'Name is required'],
        trim: true,
        minlength: [2, 'Name must be at least 2 characters'],
        maxlength: [50, 'Name cannot exceed 50 characters'],
        index: true // Create database index
    },
    
    // Email with custom validation
    email: {
        type: String,
        required: [true, 'Email is required'],
        unique: true,
        lowercase: true,
        validate: {
            validator: function(email) {
                return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);
            },
            message: 'Please provide a valid email address'
        }
    },
    
    // Number with range validation
    age: {
        type: Number,
        min: [18, 'Age must be at least 18'],
        max: [120, 'Age cannot exceed 120'],
        validate: {
            validator: Number.isInteger,
            message: 'Age must be an integer'
        }
    },
    
    // Enum with predefined values
    role: {
        type: String,
        enum: {
            values: ['user', 'admin', 'moderator'],
            message: 'Role must be either user, admin, or moderator'
        },
        default: 'user'
    },
    
    // Nested objects
    profile: {
        bio: {
            type: String,
            maxlength: 500
        },
        avatar: String,
        website: {
            type: String,
            validate: {
                validator: function(url) {
                    return url === '' || /^https?:\\/\\/.+\\..+/.test(url);
                },
                message: 'Please provide a valid URL'
            }
        }
    },
    
    // Arrays
    tags: [{
        type: String,
        lowercase: true
    }],
    
    // References to other collections
    department: {
        type: Schema.Types.ObjectId,
        ref: 'Department' // Reference to Department model
    },
    
    // GeoJSON for location data
    location: {
        type: {
            type: String,
            enum: ['Point'],
            default: 'Point'
        },
        coordinates: {
            type: [Number], // [longitude, latitude]
            index: '2dsphere'
        }
    },
    
    // Mixed type for flexible data
    metadata: Schema.Types.Mixed,
    
    // Boolean with default
    isActive: {
        type: Boolean,
        default: true
    }
    
}, {
    // Schema Options
    timestamps: true, // Adds createdAt and updatedAt automatically
    toJSON: { 
        virtuals: true,
        transform: function(doc, ret) {
            // Remove sensitive data when converting to JSON
            delete ret.password;
            delete ret.__v;
            return ret;
        }
    },
    toObject: { 
        virtuals: true,
        transform: function(doc, ret) {
            delete ret.password;
            delete ret.__v;
            return ret;
        }
    },
    id: false // Disable the default _id to id conversion
});

// ## Virtual Properties

// Virtual properties (not stored in database)
userSchema.virtual('displayName').get(function() {
    return \`\${this.name} (\${this.email})\`;
});

userSchema.virtual('profileUrl').get(function() {
    return \`/users/\${this._id}/profile\`;
});

// ## Instance Methods

// Methods available on document instances
userSchema.methods.getProfileInfo = function() {
    return \`Name: \${this.name}, Email: \${this.email}, Role: \${this.role}\`;
};

userSchema.methods.isAdmin = function() {
    return this.role === 'admin';
};

userSchema.methods.updateLastActive = function() {
    this.lastActive = new Date();
    return this.save();
};

// ## Static Methods

// Methods available on the model
userSchema.statics.findByEmail = function(email) {
    return this.findOne({ email: email.toLowerCase() });
};

userSchema.statics.findAdmins = function() {
    return this.find({ role: 'admin' });
};

userSchema.statics.findByRole = function(role) {
    return this.find({ role: role.toLowerCase() });
};

// ## Query Helpers

// Chainable query methods
userSchema.query.byName = function(name) {
    return this.where({ name: new RegExp(name, 'i') });
};

userSchema.query.active = function() {
    return this.where({ isActive: true });
};

// ## Indexes

// Compound indexes for better query performance
userSchema.index({ email: 1 }); // Single field index
userSchema.index({ name: 1, role: 1 }); // Compound index
userSchema.index({ 'location.coordinates': '2dsphere' }); // Geospatial index

// ## Middleware (Hooks)

// Pre-save middleware
userSchema.pre('save', function(next) {
    console.log(\`Saving user: \${this.name}\`);
    
    // Example: Hash password before saving
    if (this.isModified('password')) {
        // this.password = hashPassword(this.password);
    }
    
    next();
});

userSchema.pre('save', function(next) {
    // Set default values or transform data
    if (this.isNew) {
        this.createdAt = new Date();
    }
    next();
});

// Post-save middleware
userSchema.post('save', function(doc, next) {
    console.log(\`User \${doc.name} saved successfully\`);
    // Example: Send welcome email
    next();
});

// Query middleware
userSchema.pre(/^find/, function(next) {
    // Automatically populate department for all find queries
    this.populate('department');
    next();
});

// ## Validation

// Custom async validation
userSchema.path('email').validate(async function(email) {
    if (!this.isModified('email')) return true;
    
    const User = mongoose.model('User');
    const existingUser = await User.findOne({ email });
    return !existingUser;
}, 'Email already exists');

const User = mongoose.model('User', userSchema);
module.exports = User;`
    },
    {
        tabTitle: "Mongoose CRUD",
        title: "CRUD Operations & Data Manipulation",
        content: `// ## Complete CRUD Operations with Mongoose

const User = require('./models/User'); // Assuming User model is imported

// ## CREATE Operations

// Method 1: Using create() - returns promise
const createUser = async (userData) => {
    try {
        const newUser = await User.create({
            name: 'Alice Johnson',
            email: 'alice@example.com',
            age: 28,
            role: 'user',
            profile: {
                bio: 'Software developer from New York',
                website: 'https://alice.dev'
            },
            tags: ['developer', 'javascript', 'nodejs']
        });
        
        console.log('User created:', newUser);
        return newUser;
    } catch (error) {
        console.error('Error creating user:', error);
        throw error;
    }
};

// Method 2: Using save() with new instance
const createUserWithSave = async () => {
    const user = new User({
        name: 'Bob Smith',
        email: 'bob@example.com',
        age: 32
    });
    
    try {
        const savedUser = await user.save();
        console.log('User saved:', savedUser);
        return savedUser;
    } catch (error) {
        console.error('Error saving user:', error);
        throw error;
    }
};

// Method 3: Insert multiple documents
const createMultipleUsers = async () => {
    const users = [
        { name: 'Charlie Brown', email: 'charlie@example.com', age: 25 },
        { name: 'Diana Prince', email: 'diana@example.com', age: 30 },
        { name: 'Edward Wilson', email: 'edward@example.com', age: 28 }
    ];
    
    try {
        const result = await User.insertMany(users);
        console.log('Users created:', result.length);
        return result;
    } catch (error) {
        console.error('Error creating multiple users:', error);
        throw error;
    }
};

// ## READ Operations

// Find all users
const getAllUsers = async () => {
    try {
        const users = await User.find();
        console.log('Total users:', users.length);
        return users;
    } catch (error) {
        console.error('Error fetching users:', error);
        throw error;
    }
};

// Find with conditions
const getAdultUsers = async () => {
    try {
        const users = await User.find({ 
            age: { $gte: 18 },
            isActive: true 
        });
        return users;
    } catch (error) {
        console.error('Error fetching adult users:', error);
        throw error;
    }
};

// Find single document
const getUserByEmail = async (email) => {
    try {
        const user = await User.findOne({ email: email.toLowerCase() });
        return user;
    } catch (error) {
        console.error('Error finding user:', error);
        throw error;
    }
};

// Find by ID
const getUserById = async (id) => {
    try {
        const user = await User.findById(id);
        if (!user) {
            throw new Error('User not found');
        }
        return user;
    } catch (error) {
        console.error('Error finding user by ID:', error);
        throw error;
    }
};

// Advanced queries with projection
const getUsersWithProjection = async () => {
    try {
        const users = await User.find(
            { role: 'user' }, // Filter
            'name email age' // Projection (include only these fields)
        );
        return users;
    } catch (error) {
        console.error('Error with projection:', error);
        throw error;
    }
};

// Complex queries with operators
const advancedQueries = async () => {
    try {
        // Users between 25 and 35 years old
        const ageRangeUsers = await User.find({
            age: { $gte: 25, $lte: 35 }
        });
        
        // Users with specific tags
        const taggedUsers = await User.find({
            tags: { $in: ['developer', 'javascript'] }
        });
        
        // Text search (requires text index)
        const searchedUsers = await User.find({
            $text: { $search: 'software developer' }
        });
        
        // Geospatial queries
        const nearbyUsers = await User.find({
            'location.coordinates': {
                $near: {
                    $geometry: {
                        type: 'Point',
                        coordinates: [longitude, latitude]
                    },
                    $maxDistance: 10000 // 10km radius
                }
            }
        });
        
        return {
            ageRangeUsers,
            taggedUsers,
            searchedUsers,
            nearbyUsers
        };
    } catch (error) {
        console.error('Error in advanced queries:', error);
        throw error;
    }
};

// ## UPDATE Operations

// Update single document
const updateUserAge = async (userId, newAge) => {
    try {
        const result = await User.updateOne(
            { _id: userId },
            { 
                $set: { 
                    age: newAge,
                    updatedAt: new Date()
                } 
            }
        );
        
        console.log('Update result:', result);
        return result;
    } catch (error) {
        console.error('Error updating user:', error);
        throw error;
    }
};

// Find and update (returns updated document)
const findAndUpdateUser = async (email, updates) => {
    try {
        const updatedUser = await User.findOneAndUpdate(
            { email: email },
            { $set: updates },
            { 
                new: true, // Return updated document
                runValidators: true // Run schema validators
            }
        );
        
        return updatedUser;
    } catch (error) {
        console.error('Error in find and update:', error);
        throw error;
    }
};

// Update multiple documents
const updateMultipleUsers = async () => {
    try {
        const result = await User.updateMany(
            { role: 'user' },
            { 
                $set: { 
                    lastLogin: new Date(),
                    loginCount: { $inc: 1 } // Increment login count
                } 
            }
        );
        
        console.log('Updated users:', result.modifiedCount);
        return result;
    } catch (error) {
        console.error('Error updating multiple users:', error);
        throw error;
    }
};

// ## DELETE Operations

// Delete single document
const deleteUser = async (userId) => {
    try {
        const result = await User.deleteOne({ _id: userId });
        console.log('Delete result:', result);
        return result;
    } catch (error) {
        console.error('Error deleting user:', error);
        throw error;
    }
};

// Find and delete
const findAndDeleteUser = async (email) => {
    try {
        const deletedUser = await User.findOneAndDelete({ email: email });
        return deletedUser;
    } catch (error) {
        console.error('Error in find and delete:', error);
        throw error;
    }
};

// Delete multiple documents
const deleteInactiveUsers = async () => {
    try {
        const result = await User.deleteMany({
            isActive: false,
            lastLogin: { $lt: new Date(Date.now() - 365 * 24 * 60 * 60 * 1000) } // Older than 1 year
        });
        
        console.log('Deleted inactive users:', result.deletedCount);
        return result;
    } catch (error) {
        console.error('Error deleting inactive users:', error);
        throw error;
    }
};

// ## Aggregation Operations

const userAnalytics = async () => {
    try {
        const analytics = await User.aggregate([
            // Stage 1: Match active users
            {
                $match: {
                    isActive: true
                }
            },
            
            // Stage 2: Group by role and calculate statistics
            {
                $group: {
                    _id: '$role',
                    count: { $sum: 1 },
                    averageAge: { $avg: '$age' },
                    minAge: { $min: '$age' },
                    maxAge: { $max: '$age' },
                    users: { $push: '$name' }
                }
            },
            
            // Stage 3: Sort by count descending
            {
                $sort: { count: -1 }
            },
            
            // Stage 4: Project final format
            {
                $project: {
                    role: '$_id',
                    _id: 0,
                    count: 1,
                    averageAge: { $round: ['$averageAge', 1] },
                    ageRange: {
                        min: '$minAge',
                        max: '$maxAge'
                    },
                    sampleUsers: { $slice: ['$users', 3] } // First 3 users
                }
            }
        ]);
        
        return analytics;
    } catch (error) {
        console.error('Error in aggregation:', error);
        throw error;
    }
};

// ## Population (Joins)

const getUsersWithDepartments = async () => {
    try {
        const users = await User.find()
            .populate('department') // Populate department reference
            .populate('manager', 'name email') // Populate with selected fields
            .exec();
        
        return users;
    } catch (error) {
        console.error('Error populating users:', error);
        throw error;
    }
};

// ## Advanced Query Techniques

// Pagination
const getUsersPaginated = async (page = 1, limit = 10) => {
    try {
        const skip = (page - 1) * limit;
        
        const [users, total] = await Promise.all([
            User.find()
                .skip(skip)
                .limit(limit)
                .sort({ createdAt: -1 }),
            User.countDocuments()
        ]);
        
        return {
            users,
            pagination: {
                page,
                limit,
                total,
                pages: Math.ceil(total / limit)
            }
        };
    } catch (error) {
        console.error('Error in pagination:', error);
        throw error;
    }
};

// Transaction example
const transferUserData = async (fromUserId, toUserId) => {
    const session = await mongoose.startSession();
    
    try {
        session.startTransaction();
        
        const fromUser = await User.findById(fromUserId).session(session);
        const toUser = await User.findById(toUserId).session(session);
        
        // Perform operations within transaction
        // await User.updateOne({ _id: fromUserId }, { $set: {...} }).session(session);
        // await User.updateOne({ _id: toUserId }, { $set: {...} }).session(session);
        
        await session.commitTransaction();
        console.log('Transaction completed');
    } catch (error) {
        await session.abortTransaction();
        console.error('Transaction aborted:', error);
        throw error;
    } finally {
        session.endSession();
    }
};

module.exports = {
    createUser,
    getAllUsers,
    getUserById,
    updateUserAge,
    deleteUser,
    userAnalytics,
    getUsersPaginated
};`
    },
];

// Updated Questions array aligned with the new topics
const questions = [
    // MongoDB Setup
    {
        type: "question",
        question: "What is the main advantage of using MongoDB Atlas over local MongoDB installation?",
        options: [
            "It's always free with unlimited storage",
            "It provides automated backups, scaling, and managed infrastructure",
            "It doesn't require any configuration",
            "It only works with JavaScript applications"
        ],
        correctIndex: 1
    },
    {
        type: "question",
        question: "Which connection string format is used for MongoDB Atlas clusters?",
        options: [
            "mongodb://localhost:27017",
            "mysql://username:password@host:port/database",
            "mongodb+srv://username:password@cluster.mongodb.net/database",
            "postgresql://user:pass@host/db"
        ],
        correctIndex: 2
    },

    // MongoDB Compass
    {
        type: "question",
        question: "What is the primary purpose of MongoDB Compass?",
        options: [
            "To write Node.js application code",
            "To provide a graphical interface for database management and query building",
            "To deploy applications to production servers",
            "To monitor server CPU and memory usage"
        ],
        correctIndex: 1
    },
    {
        type: "question",
        question: "Which feature in MongoDB Compass allows you to visually build aggregation pipelines?",
        options: [
            "Document Validation",
            "Aggregation Pipeline Builder", 
            "Index Manager",
            "Schema Analyzer"
        ],
        correctIndex: 1
    },

    // Mongoose Basics
    {
        type: "question",
        question: "What is Mongoose in the context of Node.js and MongoDB?",
        options: [
            "A template engine for rendering HTML",
            "An Object Data Modeling (ODM) library that provides schema-based solution",
            "A testing framework for JavaScript applications",
            "A package manager for Node.js"
        ],
        correctIndex: 1
    },
    {
        type: "question",
        question: "Which Mongoose connection option controls the maximum number of sockets in the connection pool?",
        options: [
            "socketTimeoutMS",
            "maxPoolSize",
            "connectTimeoutMS", 
            "serverSelectionTimeoutMS"
        ],
        correctIndex: 1
    },

    // Mongoose Schemas
    {
        type: "question",
        question: "What is the purpose of the 'timestamps' option in a Mongoose schema?",
        options: [
            "It automatically adds createdAt and updatedAt fields to documents",
            "It creates indexes on all date fields",
            "It validates that all dates are in the correct format",
            "It converts all dates to UTC timezone"
        ],
        correctIndex: 0
    },
    {
        type: "question",
        question: "Which Mongoose feature allows you to create properties that are computed from other fields but not stored in the database?",
        options: [
            "Instance methods",
            "Static methods",
            "Virtual properties",
            "Middleware hooks"
        ],
        correctIndex: 2
    },
    {
        type: "question",
        question: "What is the main purpose of Mongoose middleware (pre and post hooks)?",
        options: [
            "To create database indexes automatically",
            "To execute logic before or after specific operations like save, find, etc.",
            "To generate API documentation from schemas",
            "To optimize database queries for better performance"
        ],
        correctIndex: 1
    },

    // Mongoose CRUD
    {
        type: "question",
        question: "What is the difference between findOne() and findById() in Mongoose?",
        options: [
            "findOne() is faster than findById()",
            "findById() specifically searches by the _id field while findOne() can search by any field",
            "findOne() returns an array while findById() returns a single document",
            "There is no difference, they are aliases for the same method"
        ],
        correctIndex: 1
    },
    {
        type: "question",
        question: "Which method is used to update a document and return the updated version in a single operation?",
        options: [
            "updateOne()",
            "updateMany()",
            "findOneAndUpdate() with {new: true}",
            "save() after modification"
        ],
        correctIndex: 2
    },
    {
        type: "question",
        question: "What is the purpose of the populate() method in Mongoose?",
        options: [
            "To fill a collection with sample data for testing",
            "To replace document references with actual documents from other collections",
            "To increase database performance by caching queries",
            "To validate all documents in a collection"
        ],
        correctIndex: 1
    },

    // Advanced Mongoose
    {
        type: "question",
        question: "What are Mongoose discriminators used for?",
        options: [
            "To distinguish between different error types",
            "To create schema inheritance and model different types of documents in the same collection",
            "To discriminate between valid and invalid queries",
            "To create different database connections for different environments"
        ],
        correctIndex: 1
    },
    {
        type: "question",
        question: "Which Mongoose feature allows you to group multiple database operations into a single atomic transaction?",
        options: [
            "Aggregation pipelines",
            "Middleware hooks",
            "Sessions with transactions",
            "Query builders"
        ],
        correctIndex: 2
    },
    {
        type: "question",
        question: "What is the purpose of the lean() method in Mongoose queries?",
        options: [
            "To make queries run faster by returning plain JavaScript objects instead of Mongoose documents",
            "To reduce the memory usage of the Node.js application",
            "To remove all validation from the query results",
            "To automatically remove sensitive fields from returned documents"
        ],
        correctIndex: 0
    },

    // Advanced Express
    {
        type: "question",
        question: "What is the main purpose of the Helmet.js middleware in Express applications?",
        options: [
            "To compress response bodies",
            "To set various HTTP headers for security protection",
            "To rate limit incoming requests",
            "To handle CORS configuration"
        ],
        correctIndex: 1
    },
    {
        type: "question",
        question: "In Express error handling, what is the advantage of using asyncHandler?",
        options: [
            "It makes all routes run asynchronously by default",
            "It automatically catches both synchronous and asynchronous errors in route handlers",
            "It converts callback-based functions to promise-based ones",
            "It adds retry logic for failed database operations"
        ],
        correctIndex: 1
    },

    // Practical Tasks - MongoDB & Tools
    {
        type: "task",
        title: "MongoDB Atlas Cluster Setup",
        content: "Create a MongoDB Atlas cluster, configure database access with proper security settings, set up network access rules, and test the connection. Create separate database users for development and production environments."
    },
    {
        type: "task",
        title: "MongoDB Compass Mastery",
        content: "Use MongoDB Compass to explore your database, create and edit documents visually, build complex queries using the GUI, analyze query performance, create indexes, and use the aggregation pipeline builder. Export your database schema analysis."
    },

    // Practical Tasks - Mongoose Basics
    {
        type: "task",
        title: "Mongoose Connection Management",
        content: "Implement a robust database connection module with connection pooling, proper error handling, reconnection logic, and graceful shutdown. Add connection state monitoring and environment-specific configurations."
    },
    {
        type: "task", 
        title: "Advanced Schema Design",
        content: "Design and implement comprehensive Mongoose schemas for a social media application including users, posts, comments, and reactions. Add proper validation, virtual properties, instance/static methods, and middleware hooks."
    },

    // Practical Tasks - Mongoose CRUD
    {
        type: "task",
        title: "Complete CRUD API Implementation",
        content: "Build a complete REST API with full CRUD operations using Mongoose. Implement filtering, sorting, pagination, population of related data, and proper error handling. Add transaction support for complex operations."
    },
    {
        type: "task",
        title: "Advanced Query Building",
        content: "Create advanced Mongoose queries including aggregation pipelines, text search, geospatial queries, and complex filtering. Implement query performance optimization and indexing strategies."
    },

    // Practical Tasks - Advanced Mongoose
    {
        type: "task",
        title: "Mongoose Plugins & Middleware",
        content: "Create reusable Mongoose plugins for common functionality like soft delete, audit logging, and data encryption. Implement advanced middleware patterns for cross-cutting concerns."
    },
    {
        type: "task",
        title: "Database Transactions & Change Streams",
        content: "Implement complex database transactions for multi-document operations and set up change streams for real-time data updates. Create proper error handling and rollback mechanisms."
    },

    // Search & Research Tasks
    {
        type: "search-task",
        title: "Research: Mongoose Performance Optimization",
        content: "Research and document Mongoose performance optimization techniques including connection pooling, query optimization, indexing strategies, and memory management. Create performance benchmarks for different query patterns."
    },
    {
        type: "search-task", 
        title: "Research: MongoDB Best Practices",
        content: "Research MongoDB best practices for schema design, indexing, aggregation pipelines, and data modeling. Compare different approaches for common use cases and create implementation guidelines."
    },

    // Integration & Production Tasks
    {
        type: "task",
        title: "Full Stack Application Integration",
        content: "Build a complete full-stack application integrating Express.js, Mongoose, and MongoDB Atlas. Implement user authentication, real-time features, proper error handling, and production-ready configurations."
    },
    {
        type: "task",
        title: "Production Deployment & Monitoring",
        content: "Prepare your Mongoose/Express application for production deployment. Configure environment variables, set up monitoring, implement health checks, create backup strategies, and set up performance monitoring."
    }
];    // Set lecture title and subtitle
        document.getElementById('lecture-title').textContent = lectureConfig.title;
        document.getElementById('lecture-subtitle').textContent = lectureConfig.subtitle;
        
        // Render tabs and content
        function renderTabsAndContent() {
            const tabsContainer = document.getElementById('tabs-container');
            const contentContainer = document.getElementById('tab-content-container');
            
            // Create tabs
            const tabs = document.createElement('div');
            tabs.className = 'tabs';
            
            // Create tab content areas
            lectureContent.forEach((content, index) => {
                // Create tab
                const tab = document.createElement('div');
                tab.className = 'tab' + (index === 0 ? ' active' : '');
                tab.textContent = content.tabTitle;
                tab.onclick = () => switchTab(index);
                tabs.appendChild(tab);
                
                // Create content
                const tabContent = document.createElement('div');
                tabContent.className = 'tab-content' + (index === 0 ? ' active' : '');
                tabContent.id = 'tab-' + index;
                
                // Add title
                const title = document.createElement('h3');
                title.textContent = content.title;
                tabContent.appendChild(title);
                
                // Add code content
                const pre = document.createElement('pre');
                const code = document.createElement('code');
                code.textContent = content.content;
                pre.appendChild(code);
                tabContent.appendChild(pre);

                // Add table if exists
                if (content.table) {
                    const table = document.createElement('table');
                    table.className = 'comparison-table';
                    
                    // Create header
                    const thead = document.createElement('thead');
                    const headerRow = document.createElement('tr');
                    content.table.headers.forEach(headerText => {
                        const th = document.createElement('th');
                        th.textContent = headerText;
                        headerRow.appendChild(th);
                    });
                    thead.appendChild(headerRow);
                    table.appendChild(thead);
                    
                    // Create body
                    const tbody = document.createElement('tbody');
                    content.table.rows.forEach(rowData => {
                        const row = document.createElement('tr');
                        rowData.forEach(cellData => {
                            const td = document.createElement('td');
                            td.textContent = cellData;
                            row.appendChild(td);
                        });
                        tbody.appendChild(row);
                    });
                    table.appendChild(tbody);
                    
                    tabContent.appendChild(table);
                }
                
                
                contentContainer.appendChild(tabContent);
            });
            
            tabsContainer.appendChild(tabs);
        }
        
        // Switch tabs function
        function switchTab(index) {
            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Add active class to clicked tab
            tabs[index].classList.add('active');
            
            // Hide all tab content
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => content.classList.remove('active'));
            
            // Show selected tab content
            document.getElementById('tab-' + index).classList.add('active');
        }
        
        // Render questions and tasks
        function renderQuestions() {
            const container = document.getElementById('questions-container');
            
            questions.forEach((q, index) => {
                if (q.type === 'question') {
                    const questionDiv = document.createElement('div');
                    questionDiv.className = 'question';
                    
                    const questionTitle = document.createElement('h3');
                    questionTitle.textContent = `Question ${index + 1}: ${q.question}`;
                    questionDiv.appendChild(questionTitle);
                    
                    if (q.code) {
                        const pre = document.createElement('pre');
                        const code = document.createElement('code');
                        code.textContent = q.code;
                        pre.appendChild(code);
                        questionDiv.appendChild(pre);
                    }
                    
                    const optionsDiv = document.createElement('div');
                    optionsDiv.className = 'options';
                    
                    q.options.forEach((option, optIndex) => {
                        const optionDiv = document.createElement('div');
                        optionDiv.className = 'option';
                        optionDiv.textContent = option;
                        optionDiv.onclick = function() {
                            checkAnswer(this, optIndex === q.correctIndex ? 'correct' : 'incorrect');
                        };
                        optionsDiv.appendChild(optionDiv);
                    });
                    
                    questionDiv.appendChild(optionsDiv);
                    
                    const resultDiv = document.createElement('div');
                    resultDiv.className = 'result';
                    resultDiv.id = 'result-' + index;
                    questionDiv.appendChild(resultDiv);
                    
                    container.appendChild(questionDiv);
                } else if (q.type === 'task') {
                    const taskDiv = document.createElement('div');
                    taskDiv.className = 'task';
                    
                    const taskTitle = document.createElement('h3');
                    taskTitle.textContent = q.title;
                    taskDiv.appendChild(taskTitle);
                    
                    const taskContent = document.createElement('p');
                    taskContent.textContent = q.content;
                    taskDiv.appendChild(taskContent);
                    
                    container.appendChild(taskDiv);
                } else if (q.type === 'search-task') {
                    const searchTaskDiv = document.createElement('div');
                    searchTaskDiv.className = 'search-task';
                    
                    const taskTitle = document.createElement('h3');
                    taskTitle.textContent = q.title;
                    searchTaskDiv.appendChild(taskTitle);
                    
                    const taskContent = document.createElement('p');
                    taskContent.textContent = q.content;
                    searchTaskDiv.appendChild(taskContent);
                    
                    container.appendChild(searchTaskDiv);
                }
            });
        }
        
        // Check answer function
        function checkAnswer(element, type) {
            const options = element.parentElement.querySelectorAll('.option');
            options.forEach(opt => {
                opt.classList.remove('correct', 'incorrect');
                opt.onclick = null;
            });
            
            element.classList.add(type);
            
            const resultId = element.closest('.question').querySelector('.result').id;
            const resultDiv = document.getElementById(resultId);
            resultDiv.style.display = 'block';
            
            if (type === 'correct') {
                resultDiv.innerHTML = '<p style="color: #155724">✅ Correct! Good job.</p>';
                resultDiv.style.backgroundColor = '#d4edda';
            } else {
                resultDiv.innerHTML = '<p style="color: #721c24">❌ Incorrect. Try to understand why.</p>';
                resultDiv.style.backgroundColor = '#f8d7da';
            }
        }
        
        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            renderTabsAndContent();
            renderQuestions();
        });
    </script>
</body>
</html>