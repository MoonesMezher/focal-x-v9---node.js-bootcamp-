<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Focal X - Node.js Bootcamp: Lecture 21 </title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: #333;
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .footer {
            padding-top: 30px;
        }

        .footer a {
            color: black;
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }
        
        .container {
            width: 100%;
            max-width: 1200px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .coach {
            background-color: white;
            width: 80px;
            border-radius: 0 0 50% 0;
            color: black;
            padding: 10px;
            position: absolute;
            left: 0;
            top: 0;
        }
        
        header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
            height: 65vh;
        }
        
        .lecture-content {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }
        
        .interactive-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }
        
        h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
            font-size: 1.5rem;
        }
        
        h3 {
            color: #2980b9;
            margin: 20px 0 12px;
            font-size: 1.2rem;
        }
        
        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 12px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 12px 0;
            font-size: 0.9rem;
        }
        
        code {
            font-family: 'Fira Code', monospace;
        }
        
        .question {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }
        
        .options {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin: 12px 0;
        }
        
        .option {
            padding: 10px;
            background: #e8f4fc;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 0.9rem;
        }
        
        .option:hover {
            background: #d1e9fa;
        }
        
        .correct {
            background: #d4edda;
            border: 1px solid #c3e6cb;
        }
        
        .incorrect {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
        }
        
        .task {
            background: #fff3cd;
            padding: 12px;
            border-left: 5px solid #ffc107;
            margin: 15px 0;
            border-radius: 5px;
            font-size: 0.9rem;
        }
        
        .btn {
            display: inline-block;
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s;
            margin-top: 8px;
        }
        
        .btn:hover {
            background: #2980b9;
        }
        
        .result {
            margin-top: 12px;
            padding: 12px;
            border-radius: 5px;
            display: none;
            font-size: 0.9rem;
        }
        
        .search-task {
            background: #e7f5e9;
            padding: 12px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 5px solid #28a745;
            font-size: 0.9rem;
        }
        
        .tabs {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }
        
        .tab {
            padding: 8px 15px;
            cursor: pointer;
            background: #f1f1f1;
            border: 1px solid #ddd;
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }
        
        .tab.active {
            background: #6f42c1;
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 12px 0;
            font-size: 0.9rem;
        }
        
        .comparison-table th, .comparison-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        
        .comparison-table th {
            background-color: #3498db;
            color: white;
        }
        
        .comparison-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        @media (max-width: 900px) {
            .content {
                grid-template-columns: 1fr;
                height: auto;
            }
            
            .lecture-content, .interactive-section {
                height: 50vh;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <p class="coach">Moones Mezher</p>
        <header>
            <h1 id="lecture-title">Focal X - Node.js Bootcamp</h1>
            <p class="subtitle" id="lecture-subtitle">Node</p>
        </header>
        
        <div class="content">
            <div class="lecture-content">
                <h2>Lecture Content</h2>
                <div id="tabs-container"></div>
                <div id="tab-content-container"></div>
            </div>
            
            <div class="interactive-section">
                <h2>Interactive Questions & Tasks</h2>
                <div id="questions-container"></div>
            </div>
        </div>
    </div>

    <footer class="footer">
        <p>&copy; 2025 <a rel="noopener" href="https://focal-x.com/" target="_blank">Focal X</a> All Right Reserved</p>
    </footer>

    <script>
        // ==================== CONFIGURATION ====================
        // Update these arrays to change the content of your lecture
        
        // Lecture metadata
        const lectureConfig = {
            title: "Focal X - Node.js Bootcamp",
            subtitle: "MongoDB & ExpressJS (Advanced)"
        };
        
       // Lecture content organized by tabs
const lectureContent = [
    {
        tabTitle: "Last Lesson",
        title: "Last Lesson Recap",
        content: `/*
1- MongoDB Setup
2- MongoDB Compass
3- Mongoose Basics
4- Mongoose Schemas
5- Mongoose CRUD
*/`
    },
    {
        tabTitle: "Chaining & Pagination",
        title: "Query Chaining, Pagination & Projection",
        content: `// ## Mongoose Query Chaining & Pagination

// Basic Chaining Examples
const users = await User.find()
  .where('age').gte(18)
  .where('isActive').equals(true)
  .select('name email age')  // Projection - include only these fields
  .sort({ createdAt: -1 })   // Sort by newest first
  .skip(10)                  // Pagination - skip first 10
  .limit(5);                 // Pagination - get 5 documents

// Projection - Include/Exclude fields
User.find().select('name email -_id');        // Include name, email, exclude _id
User.find().select('-password -__v');         // Exclude sensitive fields

// Counting documents
const count = await User.countDocuments({ age: { $gt: 18 } });
const activeCount = await User.countDocuments({ isActive: true });

// Complete Pagination Function
const getPaginatedUsers = async (page = 1, limit = 10, filters = {}) => {
    const skip = (page - 1) * limit;
    
    const [data, total] = await Promise.all([
        User.find(filters)
            .select('-password')
            .sort({ createdAt: -1 })
            .skip(skip)
            .limit(limit),
        User.countDocuments(filters)
    ]);
    
    return {
        data,
        pagination: {
            page,
            limit,
            total,
            pages: Math.ceil(total / limit)
        }
    };
};

// Usage
const result = await getPaginatedUsers(1, 10, { role: 'user' });
console.log(result.pagination); // { page: 1, limit: 10, total: 100, pages: 10 }`
    },
     {
        tabTitle: "Relationships",
        title: "MongoDB Relationships & Population",
        content: `// ## MongoDB Relationships

// 1. One-to-Many (Reference)
const userSchema = new Schema({
    name: String,
    posts: [{ type: Schema.Types.ObjectId, ref: 'Post' }] // Array of references
});

const postSchema = new Schema({
    title: String,
    author: { type: Schema.Types.ObjectId, ref: 'User' }, // Single reference
    content: String
});

// 2. Embedding (One-to-Few)
const userWithAddressSchema = new Schema({
    name: String,
    addresses: [{  // Embedded array
        street: String,
        city: String,
        country: String,
        isPrimary: Boolean
    }]
});

// 3. Junction Model (Many-to-Many)
const orderSchema = new Schema({
    user: { type: Schema.Types.ObjectId, ref: 'User' },
    products: [{
        product: { type: Schema.Types.ObjectId, ref: 'Product' },
        quantity: Number,
        price: Number
    }]
});

// ## Population Examples

// Basic population
const user = await User.findById(userId).populate('posts');

// Selective population
const userWithPosts = await User.findById(userId)
    .populate('posts', 'title createdAt')  // Only get title and createdAt
    .populate('department', 'name');

// Nested population
const postWithAuthor = await Post.findById(postId)
    .populate({
        path: 'author',
        select: 'name email',
        populate: {
            path: 'department',
            select: 'name'
        }
    });

// Multiple populations
const populatedUser = await User.findById(userId)
    .populate('posts')
    .populate('comments')
    .populate('likes');`
    },
   {
        tabTitle: "Advanced Mongoose",
        title: "Advanced Mongoose Features & Best Practices",
        content: `// ## Advanced Mongoose Patterns

// ## 1. Database Transactions

const transferOwnership = async (fromUserId, toUserId, assetId) => {
    const session = await mongoose.startSession();
    
    try {
        session.startTransaction();
        
        // Remove asset from current owner
        const fromUser = await User.findByIdAndUpdate(
            fromUserId,
            { $pull: { assets: assetId } },
            { session, new: true }
        );
        
        // Add asset to new owner
        const toUser = await User.findByIdAndUpdate(
            toUserId,
            { $push: { assets: assetId } },
            { session, new: true }
        );
        
        // Update asset ownership
        const asset = await Asset.findByIdAndUpdate(
            assetId,
            { owner: toUserId },
            { session, new: true }
        );
        
        await session.commitTransaction();
        
        return { fromUser, toUser, asset };
    } catch (error) {
        await session.abortTransaction();
        throw error;
    } finally {
        session.endSession();
    }
};

// ## 2. Advanced Middleware Patterns

const advancedUserSchema = new Schema({
    // ... schema fields
}, {
    timestamps: true
});

// Conditional middleware
advancedUserSchema.pre('save', function(next) {
    if (this.isModified('email')) {
        this.emailVerified = false;
        this.verificationToken = generateToken();
    }
    next();
});

// Async middleware
advancedUserSchema.pre('save', async function(next) {
    if (this.isModified('password')) {
        this.password = await bcrypt.hash(this.password, 12);
    }
    next();
});

// Error handling in middleware
advancedUserSchema.post('save', function(error, doc, next) {
    if (error.name === 'MongoError' && error.code === 11000) {
        next(new Error('Duplicate key error'));
    } else {
        next(error);
    }
});

// ## 3. Plugins System

// Reusable plugin for soft delete
function softDeletePlugin(schema) {
    schema.add({
        isDeleted: {
            type: Boolean,
            default: false,
            select: false
        },
        deletedAt: Date
    });
    
    // Exclude deleted documents by default
    schema.pre(/^find/, function(next) {
        if (!this.getOptions().includeDeleted) {
            this.where({ isDeleted: { $ne: true } });
        }
        next();
    });
    
    // Soft delete method
    schema.methods.softDelete = function() {
        this.isDeleted = true;
        this.deletedAt = new Date();
        return this.save();
    };
    
    // Restore method
    schema.methods.restore = function() {
        this.isDeleted = false;
        this.deletedAt = undefined;
        return this.save();
    };
    
    // Static method to find including deleted
    schema.statics.findIncludingDeleted = function(conditions) {
        return this.find(conditions).setOptions({ includeDeleted: true });
    };
}

// Apply plugin to schema
advancedUserSchema.plugin(softDeletePlugin);

// ## 4. Advanced Validation

const advancedValidationSchema = new Schema({
    username: {
        type: String,
        required: true,
        validate: {
            validator: async function(username) {
                // Async validation - check if username is unique
                const user = await this.constructor.findOne({ username });
                return !user || this._id.equals(user._id);
            },
            message: 'Username already exists'
        }
    },
    password: {
        type: String,
        validate: {
            validator: function(password) {
                return /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$/.test(password);
            },
            message: 'Password must contain uppercase, lowercase, number, and be at least 8 characters'
        }
    },
    birthDate: {
        type: Date,
        validate: {
            validator: function(date) {
                return date < new Date();
            },
            message: 'Birth date cannot be in the future'
        }
    }
});

// ## 5. Discriminators (Schema Inheritance)

const optionsSchema = new Schema({
    settings: Schema.Types.Mixed,
    preferences: Schema.Types.Mixed
}, { discriminatorKey: 'userType' });

const BaseUser = mongoose.model('BaseUser', optionsSchema);

// Admin user discriminator
const AdminUser = BaseUser.discriminator('AdminUser', new Schema({
    permissions: [String],
    adminLevel: {
        type: String,
        enum: ['super', 'normal', 'limited']
    }
}));

// Customer user discriminator
const CustomerUser = BaseUser.discriminator('CustomerUser', new Schema({
    subscription: String,
    loyaltyPoints: Number
}));

// ## 6. Advanced Query Building

class UserQueryBuilder {
    constructor() {
        this.query = User.find();
    }
    
    active() {
        this.query = this.query.where('isActive').equals(true);
        return this;
    }
    
    withRole(role) {
        this.query = this.query.where('role').equals(role);
        return this;
    }
    
    createdAfter(date) {
        this.query = this.query.where('createdAt').gte(date);
        return this;
    }
    
    withTags(tags) {
        this.query = this.query.where('tags').in(tags);
        return this;
    }
    
    paginate(page = 1, limit = 10) {
        const skip = (page - 1) * limit;
        this.query = this.query.skip(skip).limit(limit);
        return this;
    }
    
    sort(field, direction = 'asc') {
        const sortOrder = direction === 'desc' ? -1 : 1;
        this.query = this.query.sort({ [field]: sortOrder });
        return this;
    }
    
    async execute() {
        return await this.query.exec();
    }
}

// Usage
const users = await new UserQueryBuilder()
    .active()
    .withRole('admin')
    .createdAfter(new Date('2023-01-01'))
    .paginate(1, 20)
    .sort('createdAt', 'desc')
    .execute();

// ## 7. Performance Optimization

const performanceOptimizedSchema = new Schema({
    // Schema with performance considerations
    email: { type: String, index: true },
    role: { type: String, index: true },
    createdAt: { type: Date, index: true }
});

// Compound indexes for common query patterns
performanceOptimizedSchema.index({ role: 1, createdAt: -1 });
performanceOptimizedSchema.index({ isActive: 1, lastLogin: -1 });

// Partial indexes
performanceOptimizedSchema.index(
    { email: 1 },
    { 
        partialFilterExpression: { 
            email: { $exists: true } 
        } 
    }
);

// ## 8. Advanced Aggregation

const getUserStatistics = async () => {
    return await User.aggregate([
        {
            $facet: {
                // Total statistics
                totalStats: [
                    {
                        $group: {
                            _id: null,
                            totalUsers: { $sum: 1 },
                            averageAge: { $avg: '$age' },
                            activeUsers: {
                                $sum: { $cond: ['$isActive', 1, 0] }
                            }
                        }
                    }
                ],
                
                // Role distribution
                roleDistribution: [
                    {
                        $group: {
                            _id: '$role',
                            count: { $sum: 1 },
                            averageAge: { $avg: '$age' }
                        }
                    },
                    { $sort: { count: -1 } }
                ],
                
                // Monthly signups
                monthlySignups: [
                    {
                        $group: {
                            _id: {
                                year: { $year: '$createdAt' },
                                month: { $month: '$createdAt' }
                            },
                            signups: { $sum: 1 }
                        }
                    },
                    { $sort: { '_id.year': 1, '_id.month': 1 } }
                ],
                
                // Age groups
                ageGroups: [
                    {
                        $bucket: {
                            groupBy: '$age',
                            boundaries: [18, 25, 35, 45, 55, 65, 120],
                            default: 'Other',
                            output: {
                                count: { $sum: 1 },
                                users: { $push: '$name' }
                            }
                        }
                    }
                ]
            }
        }
    ]);
};

// ## 9. Change Streams (Real-time updates)

const setupUserChangeStream = () => {
    const changeStream = User.watch();
    
    changeStream.on('change', (change) => {
        console.log('Change detected:', change);
        
        // Handle different operation types
        switch (change.operationType) {
            case 'insert':
                console.log('New user created:', change.fullDocument);
                break;
            case 'update':
                console.log('User updated:', change.documentKey);
                break;
            case 'delete':
                console.log('User deleted:', change.documentKey);
                break;
        }
    });
    
    changeStream.on('error', (error) => {
        console.error('Change stream error:', error);
    });
    
    return changeStream;
};

// ## 10. Best Practices Summary

/*
Production Best Practices:
1. Always use connection pooling
2. Implement proper error handling
3. Use transactions for multiple operations
4. Create indexes for frequent queries
5. Monitor query performance
6. Use lean() for read-only operations
7. Implement proper validation
8. Use middleware for cross-cutting concerns
9. Monitor memory usage with large datasets
10. Implement proper logging and monitoring
*/

module.exports = {
    transferOwnership,
    UserQueryBuilder,
    getUserStatistics,
    setupUserChangeStream,
    AdminUser,
    CustomerUser
};`
    },
    {
        tabTitle: "Advanced Express",
        title: "Production-Ready Express Applications",
        content: `/*
Production Best Practices:
‚Ä¢ Environment configuration
‚Ä¢ Security headers
‚Ä¢ Rate limiting
‚Ä¢ Request sanitization
‚Ä¢ Proper error handling
‚Ä¢ Logging
‚Ä¢ Performance optimization
*/

const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const compression = require('compression');

// Security middleware
app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            scriptSrc: ["'self'"],
            imgSrc: ["'self'", "data:", "https:"],
        },
    },
    crossOriginEmbedderPolicy: false
}));

// CORS configuration
app.use(cors({
    origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
    credentials: true
}));

// Rate limiting
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // limit each IP to 100 requests per windowMs
    message: {
        error: 'Too many requests from this IP, please try again later.'
    }
});
app.use('/api/', limiter);

// Compression
app.use(compression());

// Environment-based configuration
const config = {
    development: {
        port: 4000,
        host: 'localhost',
        logLevel: 'debug'
    },
    production: {
        port: process.env.PORT || 80,
        host: '0.0.0.0',
        logLevel: 'warn'
    }
};

const environment = process.env.NODE_ENV || 'development';
const currentConfig = config[environment];

// Advanced error handling
class AppError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.statusCode = statusCode;
        this.isOperational = true;
        Error.captureStackTrace(this, this.constructor);
    }
}

// Async error wrapper (avoid try-catch in every route)
const asyncHandler = (fn) => (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
};

// Example with async handler
app.get('/api/async-users', asyncHandler(async (req, res) => {
    // Simulate async operation
    const users = await Promise.resolve([...users]);
    res.json({ success: true, data: users });
}));

// Global error handler
app.use((err, req, res, next) => {
    err.statusCode = err.statusCode || 500;
    err.status = err.status || 'error';

    if (process.env.NODE_ENV === 'development') {
        res.status(err.statusCode).json({
            status: err.status,
            error: err,
            message: err.message,
            stack: err.stack
        });
    } else {
        // Production: don't leak error details
        if (err.isOperational) {
            res.status(err.statusCode).json({
                status: err.status,
                message: err.message
            });
        } else {
            console.error('ERROR üí•', err);
            res.status(500).json({
                status: 'error',
                message: 'Something went wrong!'
            });
        }
    }
});

// Graceful shutdown
process.on('SIGTERM', () => {
    console.log('SIGTERM received. Shutting down gracefully...');
    server.close(() => {
        console.log('Process terminated');
    });
});`
    }
];

// Updated Questions array aligned with the new topics
const questions = [
    // MongoDB Setup
    {
        type: "question",
        question: "What is the main advantage of using MongoDB Atlas over local MongoDB installation?",
        options: [
            "It's always free with unlimited storage",
            "It provides automated backups, scaling, and managed infrastructure",
            "It doesn't require any configuration",
            "It only works with JavaScript applications"
        ],
        correctIndex: 1
    },
    {
        type: "question",
        question: "Which connection string format is used for MongoDB Atlas clusters?",
        options: [
            "mongodb://localhost:27017",
            "mysql://username:password@host:port/database",
            "mongodb+srv://username:password@cluster.mongodb.net/database",
            "postgresql://user:pass@host/db"
        ],
        correctIndex: 2
    },

    // MongoDB Compass
    {
        type: "question",
        question: "What is the primary purpose of MongoDB Compass?",
        options: [
            "To write Node.js application code",
            "To provide a graphical interface for database management and query building",
            "To deploy applications to production servers",
            "To monitor server CPU and memory usage"
        ],
        correctIndex: 1
    },
    {
        type: "question",
        question: "Which feature in MongoDB Compass allows you to visually build aggregation pipelines?",
        options: [
            "Document Validation",
            "Aggregation Pipeline Builder", 
            "Index Manager",
            "Schema Analyzer"
        ],
        correctIndex: 1
    },

    // Mongoose Basics
    {
        type: "question",
        question: "What is Mongoose in the context of Node.js and MongoDB?",
        options: [
            "A template engine for rendering HTML",
            "An Object Data Modeling (ODM) library that provides schema-based solution",
            "A testing framework for JavaScript applications",
            "A package manager for Node.js"
        ],
        correctIndex: 1
    },
    {
        type: "question",
        question: "Which Mongoose connection option controls the maximum number of sockets in the connection pool?",
        options: [
            "socketTimeoutMS",
            "maxPoolSize",
            "connectTimeoutMS", 
            "serverSelectionTimeoutMS"
        ],
        correctIndex: 1
    },

    // Mongoose Schemas
    {
        type: "question",
        question: "What is the purpose of the 'timestamps' option in a Mongoose schema?",
        options: [
            "It automatically adds createdAt and updatedAt fields to documents",
            "It creates indexes on all date fields",
            "It validates that all dates are in the correct format",
            "It converts all dates to UTC timezone"
        ],
        correctIndex: 0
    },
    {
        type: "question",
        question: "Which Mongoose feature allows you to create properties that are computed from other fields but not stored in the database?",
        options: [
            "Instance methods",
            "Static methods",
            "Virtual properties",
            "Middleware hooks"
        ],
        correctIndex: 2
    },
    {
        type: "question",
        question: "What is the main purpose of Mongoose middleware (pre and post hooks)?",
        options: [
            "To create database indexes automatically",
            "To execute logic before or after specific operations like save, find, etc.",
            "To generate API documentation from schemas",
            "To optimize database queries for better performance"
        ],
        correctIndex: 1
    },

    // Mongoose CRUD
    {
        type: "question",
        question: "What is the difference between findOne() and findById() in Mongoose?",
        options: [
            "findOne() is faster than findById()",
            "findById() specifically searches by the _id field while findOne() can search by any field",
            "findOne() returns an array while findById() returns a single document",
            "There is no difference, they are aliases for the same method"
        ],
        correctIndex: 1
    },
    {
        type: "question",
        question: "Which method is used to update a document and return the updated version in a single operation?",
        options: [
            "updateOne()",
            "updateMany()",
            "findOneAndUpdate() with {new: true}",
            "save() after modification"
        ],
        correctIndex: 2
    },
    {
        type: "question",
        question: "What is the purpose of the populate() method in Mongoose?",
        options: [
            "To fill a collection with sample data for testing",
            "To replace document references with actual documents from other collections",
            "To increase database performance by caching queries",
            "To validate all documents in a collection"
        ],
        correctIndex: 1
    },

    // Advanced Mongoose
    {
        type: "question",
        question: "What are Mongoose discriminators used for?",
        options: [
            "To distinguish between different error types",
            "To create schema inheritance and model different types of documents in the same collection",
            "To discriminate between valid and invalid queries",
            "To create different database connections for different environments"
        ],
        correctIndex: 1
    },
    {
        type: "question",
        question: "Which Mongoose feature allows you to group multiple database operations into a single atomic transaction?",
        options: [
            "Aggregation pipelines",
            "Middleware hooks",
            "Sessions with transactions",
            "Query builders"
        ],
        correctIndex: 2
    },
    {
        type: "question",
        question: "What is the purpose of the lean() method in Mongoose queries?",
        options: [
            "To make queries run faster by returning plain JavaScript objects instead of Mongoose documents",
            "To reduce the memory usage of the Node.js application",
            "To remove all validation from the query results",
            "To automatically remove sensitive fields from returned documents"
        ],
        correctIndex: 0
    },

    // Advanced Express
    {
        type: "question",
        question: "What is the main purpose of the Helmet.js middleware in Express applications?",
        options: [
            "To compress response bodies",
            "To set various HTTP headers for security protection",
            "To rate limit incoming requests",
            "To handle CORS configuration"
        ],
        correctIndex: 1
    },
    {
        type: "question",
        question: "In Express error handling, what is the advantage of using asyncHandler?",
        options: [
            "It makes all routes run asynchronously by default",
            "It automatically catches both synchronous and asynchronous errors in route handlers",
            "It converts callback-based functions to promise-based ones",
            "It adds retry logic for failed database operations"
        ],
        correctIndex: 1
    },

    // Practical Tasks - MongoDB & Tools
    {
        type: "task",
        title: "MongoDB Atlas Cluster Setup",
        content: "Create a MongoDB Atlas cluster, configure database access with proper security settings, set up network access rules, and test the connection. Create separate database users for development and production environments."
    },
    {
        type: "task",
        title: "MongoDB Compass Mastery",
        content: "Use MongoDB Compass to explore your database, create and edit documents visually, build complex queries using the GUI, analyze query performance, create indexes, and use the aggregation pipeline builder. Export your database schema analysis."
    },

    // Practical Tasks - Mongoose Basics
    {
        type: "task",
        title: "Mongoose Connection Management",
        content: "Implement a robust database connection module with connection pooling, proper error handling, reconnection logic, and graceful shutdown. Add connection state monitoring and environment-specific configurations."
    },
    {
        type: "task", 
        title: "Advanced Schema Design",
        content: "Design and implement comprehensive Mongoose schemas for a social media application including users, posts, comments, and reactions. Add proper validation, virtual properties, instance/static methods, and middleware hooks."
    },

    // Practical Tasks - Mongoose CRUD
    {
        type: "task",
        title: "Complete CRUD API Implementation",
        content: "Build a complete REST API with full CRUD operations using Mongoose. Implement filtering, sorting, pagination, population of related data, and proper error handling. Add transaction support for complex operations."
    },
    {
        type: "task",
        title: "Advanced Query Building",
        content: "Create advanced Mongoose queries including aggregation pipelines, text search, geospatial queries, and complex filtering. Implement query performance optimization and indexing strategies."
    },

    // Practical Tasks - Advanced Mongoose
    {
        type: "task",
        title: "Mongoose Plugins & Middleware",
        content: "Create reusable Mongoose plugins for common functionality like soft delete, audit logging, and data encryption. Implement advanced middleware patterns for cross-cutting concerns."
    },
    {
        type: "task",
        title: "Database Transactions & Change Streams",
        content: "Implement complex database transactions for multi-document operations and set up change streams for real-time data updates. Create proper error handling and rollback mechanisms."
    },

    // Search & Research Tasks
    {
        type: "search-task",
        title: "Research: Mongoose Performance Optimization",
        content: "Research and document Mongoose performance optimization techniques including connection pooling, query optimization, indexing strategies, and memory management. Create performance benchmarks for different query patterns."
    },
    {
        type: "search-task", 
        title: "Research: MongoDB Best Practices",
        content: "Research MongoDB best practices for schema design, indexing, aggregation pipelines, and data modeling. Compare different approaches for common use cases and create implementation guidelines."
    },

    // Integration & Production Tasks
    {
        type: "task",
        title: "Full Stack Application Integration",
        content: "Build a complete full-stack application integrating Express.js, Mongoose, and MongoDB Atlas. Implement user authentication, real-time features, proper error handling, and production-ready configurations."
    },
    {
        type: "task",
        title: "Production Deployment & Monitoring",
        content: "Prepare your Mongoose/Express application for production deployment. Configure environment variables, set up monitoring, implement health checks, create backup strategies, and set up performance monitoring."
    }
];    // Set lecture title and subtitle
        document.getElementById('lecture-title').textContent = lectureConfig.title;
        document.getElementById('lecture-subtitle').textContent = lectureConfig.subtitle;
        
        // Render tabs and content
        function renderTabsAndContent() {
            const tabsContainer = document.getElementById('tabs-container');
            const contentContainer = document.getElementById('tab-content-container');
            
            // Create tabs
            const tabs = document.createElement('div');
            tabs.className = 'tabs';
            
            // Create tab content areas
            lectureContent.forEach((content, index) => {
                // Create tab
                const tab = document.createElement('div');
                tab.className = 'tab' + (index === 0 ? ' active' : '');
                tab.textContent = content.tabTitle;
                tab.onclick = () => switchTab(index);
                tabs.appendChild(tab);
                
                // Create content
                const tabContent = document.createElement('div');
                tabContent.className = 'tab-content' + (index === 0 ? ' active' : '');
                tabContent.id = 'tab-' + index;
                
                // Add title
                const title = document.createElement('h3');
                title.textContent = content.title;
                tabContent.appendChild(title);
                
                // Add code content
                const pre = document.createElement('pre');
                const code = document.createElement('code');
                code.textContent = content.content;
                pre.appendChild(code);
                tabContent.appendChild(pre);

                // Add table if exists
                if (content.table) {
                    const table = document.createElement('table');
                    table.className = 'comparison-table';
                    
                    // Create header
                    const thead = document.createElement('thead');
                    const headerRow = document.createElement('tr');
                    content.table.headers.forEach(headerText => {
                        const th = document.createElement('th');
                        th.textContent = headerText;
                        headerRow.appendChild(th);
                    });
                    thead.appendChild(headerRow);
                    table.appendChild(thead);
                    
                    // Create body
                    const tbody = document.createElement('tbody');
                    content.table.rows.forEach(rowData => {
                        const row = document.createElement('tr');
                        rowData.forEach(cellData => {
                            const td = document.createElement('td');
                            td.textContent = cellData;
                            row.appendChild(td);
                        });
                        tbody.appendChild(row);
                    });
                    table.appendChild(tbody);
                    
                    tabContent.appendChild(table);
                }
                
                
                contentContainer.appendChild(tabContent);
            });
            
            tabsContainer.appendChild(tabs);
        }
        
        // Switch tabs function
        function switchTab(index) {
            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Add active class to clicked tab
            tabs[index].classList.add('active');
            
            // Hide all tab content
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => content.classList.remove('active'));
            
            // Show selected tab content
            document.getElementById('tab-' + index).classList.add('active');
        }
        
        // Render questions and tasks
        function renderQuestions() {
            const container = document.getElementById('questions-container');
            
            questions.forEach((q, index) => {
                if (q.type === 'question') {
                    const questionDiv = document.createElement('div');
                    questionDiv.className = 'question';
                    
                    const questionTitle = document.createElement('h3');
                    questionTitle.textContent = `Question ${index + 1}: ${q.question}`;
                    questionDiv.appendChild(questionTitle);
                    
                    if (q.code) {
                        const pre = document.createElement('pre');
                        const code = document.createElement('code');
                        code.textContent = q.code;
                        pre.appendChild(code);
                        questionDiv.appendChild(pre);
                    }
                    
                    const optionsDiv = document.createElement('div');
                    optionsDiv.className = 'options';
                    
                    q.options.forEach((option, optIndex) => {
                        const optionDiv = document.createElement('div');
                        optionDiv.className = 'option';
                        optionDiv.textContent = option;
                        optionDiv.onclick = function() {
                            checkAnswer(this, optIndex === q.correctIndex ? 'correct' : 'incorrect');
                        };
                        optionsDiv.appendChild(optionDiv);
                    });
                    
                    questionDiv.appendChild(optionsDiv);
                    
                    const resultDiv = document.createElement('div');
                    resultDiv.className = 'result';
                    resultDiv.id = 'result-' + index;
                    questionDiv.appendChild(resultDiv);
                    
                    container.appendChild(questionDiv);
                } else if (q.type === 'task') {
                    const taskDiv = document.createElement('div');
                    taskDiv.className = 'task';
                    
                    const taskTitle = document.createElement('h3');
                    taskTitle.textContent = q.title;
                    taskDiv.appendChild(taskTitle);
                    
                    const taskContent = document.createElement('p');
                    taskContent.textContent = q.content;
                    taskDiv.appendChild(taskContent);
                    
                    container.appendChild(taskDiv);
                } else if (q.type === 'search-task') {
                    const searchTaskDiv = document.createElement('div');
                    searchTaskDiv.className = 'search-task';
                    
                    const taskTitle = document.createElement('h3');
                    taskTitle.textContent = q.title;
                    searchTaskDiv.appendChild(taskTitle);
                    
                    const taskContent = document.createElement('p');
                    taskContent.textContent = q.content;
                    searchTaskDiv.appendChild(taskContent);
                    
                    container.appendChild(searchTaskDiv);
                }
            });
        }
        
        // Check answer function
        function checkAnswer(element, type) {
            const options = element.parentElement.querySelectorAll('.option');
            options.forEach(opt => {
                opt.classList.remove('correct', 'incorrect');
                opt.onclick = null;
            });
            
            element.classList.add(type);
            
            const resultId = element.closest('.question').querySelector('.result').id;
            const resultDiv = document.getElementById(resultId);
            resultDiv.style.display = 'block';
            
            if (type === 'correct') {
                resultDiv.innerHTML = '<p style="color: #155724">‚úÖ Correct! Good job.</p>';
                resultDiv.style.backgroundColor = '#d4edda';
            } else {
                resultDiv.innerHTML = '<p style="color: #721c24">‚ùå Incorrect. Try to understand why.</p>';
                resultDiv.style.backgroundColor = '#f8d7da';
            }
        }
        
        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            renderTabsAndContent();
            renderQuestions();
        });
    </script>
</body>
</html>